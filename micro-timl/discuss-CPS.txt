;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with C-x C-f and enter text in its buffer.

CPS'ed code can use a stack to allocate and deallocate (When is it safe to deallocate? A continuation may be stored and called multiple times. We must assume that a continuation will only be called once after its closure's creation. This is true in C as long as we don't do pointer arithmetics.) continuation-closures' environments (as well as spilled registers). In this way it's equivalent to C's stack-based call mechanism except for a "stack (or frame) compression" step before each call, since after the call the remaining code may not need all the content in the current call-frame. We can also avoid this "frame compression" (which is good for remaining code with smart stack footprint such as for tail calls but bad for those with large footprint) by equiping every function with a "frame remapping" map to be used when calculating frame offsets. In this case the program will behave exactly as C. We can even freely choose whether to do this compression by inspecting the residual code. CPS gives us this freedom, while C can only do "frame compression" for tail calls.

--> C compilers can also choose to do a frame compression before calls. In the tradeoff between speed and stack usage, maybe modern compilers optimize for speed because memory is large and cheap.

CPS reflects low-level concepts such as return address and return site into the high-level functional language, so these concepts can be dealt with and reasoned about in the high level. It also gives a name to every return site, which C doesn't. C requires the assembly language to have a "get current PC" instruction (which is part of x86's CALL instruction), while CPS'ed code doesn't. An assembly language without a "get current PC" can be given an operational semantics on the instruction-sequence level, without mentioning PCs.

--> PC can be modeled as an instruction sequence. "Get current PC" can be modeled as getting the remaining instruction sequence of the current basic block. PCs (i.e. code addresses) can be viewed as names of basic block suffices. They are 1-to-1 corresponded. PCs give a name to every return site, just as CPS.

Without CPS, callcc is hard to implement.

--> The instruction sequence in an assembly language's operational semantics corresponds to control stack or evaluation context of a functional language's semantics; the "get current PC" instruction corresponds to "get current continuation" or "callcc"; An assembly language with the "get current PC" instruction corresponds to a functional language with callcc. In this sense CPS is only useful for implementing callcc for an assembly language without the "get current PC" instruction. Closures make things more complicated. When a C function returns, it de-stack, assuming that its call-frame is not referenced. But if during the function some code took a snapshot of the call-frame (e.g. for getting the current continuation) and stored it somewhere, these reference now becomes dangled. Functional languages don't have this problem because all closure environments (i.e. call-frames) are heap-allocated and will only be GC'ed when absolutely no reference exists. We can imagine a C implementation that heap-allocate call frames and linked their together to form the stack. Then we can safely get the current continuation (PC and the stack) and store it anywhere, as long as all variables are only written once as in functional languages. So, callcc can be implemented without CPS by using linked call-frames (and no manual deallocation).

--> A way to have "get current PC" in C: call a function and use pointer arithmetics to read the return address. It's basically a mimic of callcc.

--> Early return is less powerful than continuations, but it guarantees single invocation of continuation (no store-and-call-multiple-times), so the continuation can safely discard its call-frame (i.e. its closure environment).
