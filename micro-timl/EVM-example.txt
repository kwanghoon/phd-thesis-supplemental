0: heap free pointer (free_ptr)
32: frame pointer (frame_ptr) a.k.a. base pointer (base_ptr)

compile (reg1 * (reg2 + reg3)) ==
{// compile (Reg reg1) // get_reg reg1
push2 reg1
mload
}
{// compile (reg2 + reg3)
push1 32
mload
push2 reg2
add
mload
push1 32
mload
push2 reg3
add
mload
add
}
mul

(let reg1 = e) ==
compile(e)
{// set_reg reg1
push2 reg1
mstore
}

tuple e_1 ... e_n ==
compile(e_1)
...
compile(e_n)
{// malloc_tuple [t_1, ..., t_n]
push1 0
mload
dup1
push2 n*32
add
push1 0
mstore
}
push2 n*32
add
repeat n {
push1 32
swap1
sub
swap1
{// tuple_assign
dup2
mstore // m[m[0]+(i-1)*32] = e_i
}
}

br_sum expr inr_branch_label ==
compile(expr)
{// br_sum inr_branch_label
push32 inr_branch_label // [code, l]
swap1 // [l, code]
//unpack_sum "c"
dup1 // [l, l, code]
//push1 32
//add
//mload
//swap1
mload // [b, l, code]
swap1 // [l, b, code]
swap2 // [code, b, l]
jumpi_sum
} // [l]

inl [t_other] expr ==
compile(expr)
{// inl
{// malloc_tuple [ibool{False}, t_expr]
push1 0
mload
dup1
push1 64
add
push1 0
mstore
}
{// inl_assign [t_other]
push1 false
dup2
mstore // m[m[0]] = #false
swap1
dup2
push1 32
add
mstore // m[m[0]+32] = expr
pack_inl [t_other]
}
}

new_array e1 e2 ==
compile(e1)
compile(e2)
swap1 // [len, v]
dup1 // [len, len, v]
{// malloc_array t_e2 // [len]
push1 0 
mload // [m[0], len]
dup2 // [len, m[0], len]
dup2  // [m[0], len, m[0], len]
mstore // m[m[0]] = len // [m[0], len]
push1 32
add // [m[0]+32, len]
dup1 // [m[0]+32, m[0]+32, len]
swap2 // [len, m[0]+32, m[0]+32]
push1 32
mul
add // [m[0]+32+len*32, m[0]+32]
push1 0
mstore // m[0] = m[0] + 32 + len * 32 // [m[0]+32]
} // [m[0]+32, len, v]
swap1 // [len, m[0]+32, v]
push1 32
mul // n = len*32, arr = m[0]+32 // [len*32(i.e. n), m[0]+32(i.e. arr), v]
loop:
jumpdest
dup1 // [n, n, m[0]+32, v]
iszero // n<=0 ?
push32 loop_exit
jumpi // [n, m[0]+32, v]
push1 32
swap1
sub // [n-32, m[0]+32, v]
{// array_assign 
dup3 // [v, n-32, m[0]+32, v]
dup3 // [m[0]+32, v, n-32, m[0]+32, v]
dup3 // [n-32, m[0]+32, v, n-32, m[0]+32, v]
add  // [m[0]+32+(n-32), v, n-32, m[0]+32, v]
mstore // m[arr+(n-32)] = v // [n-32, m[0]+32, v]
}
jump loop
loop_exit: // [n(=0), m[0]+32, v]
jumpdest
pop // pop 0 // [m[0]+32, v]
swap1
pop // pop v // [m[0]+32]
// now arr is top

new_empty_array [t] ==
push1 0
malloc_array t

read e1 e2 ==
compile(e1)
compile(e2)
{// array_pt
push1 32
mul
add
}
mload

write e1 e2 e3 ==
compile(e1)
compile(e2)
compile(e3)
swap2
swap1
array_ptr 
mstore

array_len e ==
compile(e)
push1 32
swap1
sub
mload

map_get reg_i reg_(i+1) e1 e2 ==
compile(e1)
compile(e2)
{// map_ptr reg_i reg_(i+1)
push32 i*32
mstore
push2 (i+1)*32
mstore
push1 64
push32 i*32
sha3
}
sload

map_set reg_i reg_(i+1) e1 e2 e3 ==
compile(e1)
compile(e2)
compile(e3)
swap2
swap1
map_ptr reg_i reg_(i+1)
sstore

vector_get r e1 e2 ==
compile(e1)
compile(e2)
swap1
{// vector_ptr r
push2 r*32
mstore
push1 32
push32 r*32
sha3
add
}
sload

vector_set r e1 e2 e3 ==
compile(e1)
compile(e2)
compile(e3)
swap2
vector_ptr r
sstore

vector_push_back r vector_label e2
compile(e2)
{// inc length
push32 vector_label
swap1 // [v, l]
dup2 // [l, v, l]
dup1 // [l, l, v, l]
sload // [len, l, v, l]
swap1
dup2 // [len, l, len, v, l]
push1 1
add
swap1 // [l, len+1, len, v, l]
sstore // s[l] = s[l]+1 // [len, v, l]
}
swap1 // [v, len, l]
swap2 // [l, len, v]
vector_ptr r // [sha3(l)+len), v]
store // s[sha3(l)+len] = v // []
push1 ()

vector_len e ==
compile(e1)
mload

Calling convention 1:

call result_reg callee_addr_expr arg_expr ret_addr_label ==
compile(callee_addr_expr)
compile(arg_expr)
swap1
{// call ret_addr_label
{// heap_push ret_addr_label
push32 ret_addr_label
{// heap_push
{// m[free_ptr] <= top (m[m[0]] = top)
push1 0 
mload
mstore
}
{// free_ptr += 32 (m[0] = 32 + m[0])
push1 32
{// inc_free_ptr (m[0] = top + m[0])
push1 0 
mload
add
push1 0
mstore
}
}
}
}
jump
}
ret_addr_label:
jumpdest
{// pop_to base[result_reg] (m[m[32]+result_reg] = top)
push1 32
mload
push2 result_reg
add
mstore
}

function_prelude ==
{// heap_push m[base_ptr]
push1 32
mload
heap_push
}
{// base_ptr <= m[free_ptr] (m[32] = m[0])
push1 0
mload
push1 32
mstore
}
{// free_ptr += base_size
push2 base_size
inc_free_ptr
}
{// pop_to base[0] (m[m[32]] = top) (pop arg to base[0])
push1 32
mload
mstore
}

return result_expr ==
compile result_expr
{// push base[-64] (i.e. m[m[32]-64], the return ptr)
// equivalent to: compile (Reg -64)
push1 32
mload
push1 64
swap1
sub
mload
}
{// base_ptr <= base[-32] (m[32] = m[m[32]-32])
{// equivalent to: compile (Reg -32)
push1 32
mload
push1 32
swap1
sub
mload
}
push1 32
mstore
}
jump_ret // == jump

Calling convention 2:

call result_reg callee_addr_expr arg_expr ret_addr_label ==
compile(callee_addr_expr)
compile(arg_expr)
swap1
{// call ret_addr_label
push32 ret_addr_label
swap1
jump
}
ret_addr_label:
jumpdest
{// pop_to base[result_reg] (m[m[32]+result_reg] = top)
push1 32
mload
push2 result_reg
add
mstore
}

function_prelude ==
{// heap_push
{// m[free_ptr] <= top (m[m[0]] = top)
push1 0 
mload
mstore
}
{// free_ptr += 32 (m[0] = 32 + m[0])
push1 32
{// inc_free_ptr (m[0] = top + m[0])
push1 0 
mload
add
push1 0
mstore
}
}
}
{// heap_push m[base_ptr]
push1 32
mload
heap_push
}
{// base_ptr <= m[free_ptr] (m[1] = m[0])
push1 0
mload
push1 32
mstore
}
{// free_ptr += base_size
push2 base_size
inc_free_ptr
}
{// pop_to base[0] (m[m[32]] = top) (pop arg to base[0])
push1 32
mload
mstore
}

return result_expr ==
compile result_expr
{// push base[-64] (i.e. m[m[32]-64], the return ptr)
// equivalent to: compile (Reg -64)
push1 32
mload
push1 64
swap1
sub
mload
}
{// base_ptr <= base[-32] (m[32] = m[m[32]-32])
{// equivalent to: compile (Reg -32)
push1 32
mload
push1 32
swap1
sub
mload
}
push1 32
mstore
}
jump_ret // == jump

