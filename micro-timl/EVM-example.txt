0: heap free pointer (free_ptr)
32: frame pointer (frame_ptr) a.k.a. base pointer (base_ptr)

compile (reg1 * (reg2 + reg3)) ==
{// compile (Reg reg1)
// push base[arg1] (base[arg1] == m[m[base_ptr] + arg1] == m[m[32] + arg1])
push1 32
mload
push2 reg1
add
mload
}
{// compile (reg2 + reg3)
push1 32
mload
push2 reg2
add
mload
push1 32
mload
push2 reg3
add
mload
add
}
mul

br_sum expr inr_branch_label ==
compile(expr)
{// br_sum inr_branch_label
unpack_sum "c"
dup1
push1 32
add
mload
swap1
mload
push32 inr_branch_label
jumpi_sum
}

inl [t_other] expr ==
compile(expr)
{// inl
malloc_tuple [ibool{False}, t_expr]
push1 0
mload
dup1
push1 #false
swap1
mstore // m[m[0]] = #false
swap1
dup2
push1 32
add
mstore // m[m[0]+32] = expr
dup1
push1 64
add
push1 0
mstore // m[0] = m[0] + 64
pack_inl [t_other]
}

new_array e1 e2 ==
compile(e1)
compile(e2)
swap1
dup1
malloc_array i_e1 t_e2
push1 0 
mload
swap1
dup2
mstore // m[m[0]] = len
push1 32
add
dup1
dup3
push1 32
mul
add
push1 0
mstore // m[0] = m[0] + 32 + len * 32
swap1
push1 32
mul // n = len * 32
loop:
jumpdest
dup1
iszero // n<=0 ?
push32 loop_exit
jumpi
push1 32
swap1
sub
dup3
dup3
dup3
add
mstore // m[arr+(n-32)] = v
jump loop
loop_exit:
jumpdest
pop // pop 0
swap1
pop // pop v
// now arr is top

new_empty_array [t] ==
malloc_array 0 t
push1 0 
mload
push1 0
dup2
mstore // m[m[0]] = 0
push1 32
add
dup1
push1 0
mstore // m[0] = m[0] + 32


read e1 e2 ==
compile(e1)
compile(e2)
{// array_pt
push1 32
mul
add
}
mload

write e1 e2 e3 ==
compile(e1)
compile(e2)
compile(e3)
swap2
swap1
array_ptr 
mstore

array_len e ==
compile(e)
push1 32
swap1
sub
mload

tuple e_1 ... e_n ==
compile(e_1)
...
compile(e_n)
malloc_tuple [t_1, ..., t_n]
push1 0
mload
push2 n*32
add
repeat n {
push1 32
swap1
sub
dup2
dup2
mstore // m[m[0]+(i-1)*32] = e_i
}

map_get reg_i reg_(i+1) e1 e2 ==
compile(e1)
compile(e2)
{// map_ptr reg_i reg_(i+1)
push32 i*32
mstore
push2 (i+1)*32
mstore
push1 64
push32 i*32
sha3
}
sload

map_set reg_i reg_(i+1) e1 e2 e3 ==
compile(e1)
compile(e2)
compile(e3)
swap2
swap1
map_ptr reg_i reg_(i+1)
sstore

vector_get r e1 e2 ==
compile(e1)
compile(e2)
swap1
{// vector_ptr r
push2 r*32
mstore
push1 32
push32 r*32
sha3
add
}
sload

vector_set r e1 e2 e3 ==
compile(e1)
dup1
compile(e2)
compile(e3)
swap2
vector_ptr r
sstore
dup1 // update length
sload
push1 1
add
swap1
sstore

vector_len e ==
compile(e1)
mload

Calling convention 1:

call result_reg callee_addr_expr arg_expr ret_addr_label ==
compile(callee_addr_expr)
compile(arg_expr)
swap1
{// call ret_addr_label
{// heap_push ret_addr_label
push32 ret_addr_label
{// heap_push
{// m[free_ptr] <= top (m[m[0]] = top)
push1 0 
mload
mstore
}
{// free_ptr += 32 (m[0] = 32 + m[0])
push1 32
{// inc_free_ptr (m[0] = top + m[0])
push1 0 
mload
add
push1 0
mstore
}
}
}
}
jump
}
ret_addr_label:
jumpdest
{// pop_to base[result_reg] (m[m[32]+result_reg] = top)
push1 32
mload
push2 result_reg
add
mstore
}

function_prelude ==
{// heap_push m[base_ptr]
push1 32
mload
heap_push
}
{// base_ptr <= m[free_ptr] (m[32] = m[0])
push1 0
mload
push1 32
mstore
}
{// free_ptr += base_size
push2 base_size
inc_free_ptr
}
{// pop_to base[0] (m[m[32]] = top) (pop arg to base[0])
push1 32
mload
mstore
}

return result_expr ==
compile result_expr
{// push base[-64] (i.e. m[m[32]-64], the return ptr)
// equivalent to: compile (Reg -64)
push1 32
mload
push1 64
swap1
sub
mload
}
{// base_ptr <= base[-32] (m[32] = m[m[32]-32])
{// equivalent to: compile (Reg -32)
push1 32
mload
push1 32
swap1
sub
mload
}
push1 32
mstore
}
jump_ret // == jump

Calling convention 2:

call result_reg callee_addr_expr arg_expr ret_addr_label ==
compile(callee_addr_expr)
compile(arg_expr)
swap1
{// call ret_addr_label
push32 ret_addr_label
swap1
jump
}
ret_addr_label:
jumpdest
{// pop_to base[result_reg] (m[m[32]+result_reg] = top)
push1 32
mload
push2 result_reg
add
mstore
}

function_prelude ==
{// heap_push
{// m[free_ptr] <= top (m[m[0]] = top)
push1 0 
mload
mstore
}
{// free_ptr += 32 (m[0] = 32 + m[0])
push1 32
{// inc_free_ptr (m[0] = top + m[0])
push1 0 
mload
add
push1 0
mstore
}
}
}
{// heap_push m[base_ptr]
push1 32
mload
heap_push
}
{// base_ptr <= m[free_ptr] (m[1] = m[0])
push1 0
mload
push1 32
mstore
}
{// free_ptr += base_size
push2 base_size
inc_free_ptr
}
{// pop_to base[0] (m[m[32]] = top) (pop arg to base[0])
push1 32
mload
mstore
}

return result_expr ==
compile result_expr
{// push base[-64] (i.e. m[m[32]-64], the return ptr)
// equivalent to: compile (Reg -64)
push1 32
mload
push1 64
swap1
sub
mload
}
{// base_ptr <= base[-32] (m[32] = m[m[32]-32])
{// equivalent to: compile (Reg -32)
push1 32
mload
push1 32
swap1
sub
mload
}
push1 32
mstore
}
jump_ret // == jump

