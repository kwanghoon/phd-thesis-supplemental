pragma etiml ^0.1

structure Pervasive = struct
  fun inc n = n + 1
  fun addBy b a = a + b
  fun subBy b a = a - b
  fun orBy b a = a || b
  fun waste_time () = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
  fun require b = if b then waste_time (); () else (throw using _) end
  val assert = require
  val ether = 1000000000000000000
  val minute = 60
end

contract owned = struct

  open Pervasive
       
  public state owner : cell address = 0

  public fun init () =
    owner ::= msg.sender

  public fun onlyOwner () =
    require(msg.sender = !!owner)

  public fun transferOwnership (newOwner : address) =
    onlyOwner ();
    owner ::= newOwner

end

interface Token = sig
  public fun transferFrom(_from : address, _to : address, _value : uint256) return bool
end

contract tokenRecipient = struct

    open Pervasive

    event receivedEther(sender : address, amount : uint)
    event receivedTokens(_from : address, _value : uint256, _token : address, _extraData : bytes)

    public fun receiveApproval (_from : address, _value : uint256, _token : address(* , _extraData : bytes *)) =
      let t = attach _token Token;
      require(call t transferFrom( _from, this, _value));
      fire receivedTokens(_from, _value, _token, _extraData)

    public fun default () payable =
      fire receivedEther(msg.sender, msg.value)

end

contract Congress = struct inherit owned, tokenRecipient

  (* type Vote = { *)
  (*   inSupport : bool, *)
  (*   voter : address, *)
  (*   justification : string, *)
  (* } *)

  type Proposal = {
    recipient : address,
    amount : uint,
    (* description : string, *)
    votingDeadline : uint,
    executed : bool,
    proposalPassed : bool,
    numberOfVotes : uint,
    currentResult : int,
    proposalHash : bytes32,
    (* votes : vector Vote, *)
    voted : map address bool,
  }

  type Member = {
    member : address,
    (* name : string, *)
    memberSince : uint,
  }

  (* Contract Variables and events *)
  public state minimumQuorum : cell uint
  public state debatingPeriodInMinutes : cell uint
  public state majorityMargin : cell int
  public state proposals : map uint (* Proposal *){
    recipient : address,
    amount : uint,
    (* description : string, *)
    votingDeadline : uint,
    executed : bool,
    proposalPassed : bool,
    numberOfVotes : uint,
    currentResult : int,
    proposalHash : bytes32,
    (* votes : vector Vote, *)
    voted : map address bool,
  }
  public state numProposals : cell uint
  public state memberId : map address uint
  public state members : map uint (* Member *){
    member : address,
    (* name : string, *)
    memberSince : uint,
  }
  public state numMembers : icell

  event ProposalAdded(proposalID : uint, recipient : address, amount : uint, description : string)
  event Voted(proposalID : uint, position : bool, voter : address, justification : string)
  event ProposalTallied(proposalID : uint, result : int, quorum : uint, active : bool)
  event MembershipChanged(member : address, isMember : bool)
  event ChangeOfRules(newMinimumQuorum : uint, newDebatingPeriodInMinutes : uint, newMajorityMargin : int)

  (* Modifier that allows only shareholders to vote and create new proposals *)
  fun onlyMembers () =
    require(memberId[msg.sender] != 0)

  fun copy_Member (t : storage Member, s : Member) =
    &t->member ::= s.member;
    &t->memberSince ::= s.memberSince                       

  (** *)
(*    * Add member *)
(*    * *)
(*    * Make `targetMember` a member named `memberName` *)
(*    * *)
(*    * @param targetMember ethereum address to be added *)
(*    * @param memberName public name for that member *)
(*    *)
  public fun addMember {len : Nat} (targetMember : address(* , memberName : string *)) pre {numMembers : len} post {numMembers : len+1} =
    onlyOwner ();
    require(memberId[targetMember] = 0);
    let id = nat2int (!!numMembers);
    modify numMembers ++;           
    set memberId[targetMember] id;
    copy_Member(&members[id], {member = targetMember, memberSince = now, (* name = memberName,  *)} : Member );
    fire MembershipChanged(targetMember, true)

  (** *)
(*    * Constructor function *)
(*    *)
  public fun init (
        minimumQuorumForProposals : uint,
        minutesForDebate : uint,
        marginOfVotesForMajority : int
    ) payable =
    fire changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
    (* Itâ€™s necessary to add an empty first member *)
    addMember(0(* , "" *));
    (* and let's add the founder, to save a step later *)
    addMember(owner(* , 'founder' *))

  (*  (** *) *)
(*   (*   * Remove member *) *)
(*   (*   * *) *)
(*   (*   * @notice Remove membership from `targetMember` *) *)
(*   (*   * *) *)
(*   (*   * @param targetMember ethereum address to be removed *) *)
(*   (*   *) *)
  (* public fun removeMember {len : Nat | len > 0} (targetMember : address) pre {members : len} post {members : len-1} using $(4 + len * 3) guarded_by onlyOwner = *)
  (*   require(memberId[targetMember] != 0); *)
  (*   for (i : uint = memberId[targetMember]; i < length members - 1; inc) *)
  (*     set members[i] members[i+1] *)
  (*   end; *)
  (*   remove_back members *)

(*   (** *) *)
(* (*    * Change voting rules *) *)
(* (*    * *) *)
(* (*    * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours, *) *)
(* (*    * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed *) *)
(* (*    * *) *)
(* (*    * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed *) *)
(* (*    * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed *) *)
(* (*    * @param marginOfVotesForMajority the proposal needs to have 50% plus this number *) *)
(* (*    *) *)
(*   public fun changeVotingRules ( *)
(*         minimumQuorumForProposals : uint, *)
(*         minutesForDebate : uint, *)
(*         marginOfVotesForMajority : int *)
(*     ) guardedby onlyOwner = *)
(*     minimumQuorum := minimumQuorumForProposals; *)
(*     debatingPeriodInMinutes := minutesForDebate; *)
(*     majorityMargin := marginOfVotesForMajority; *)

(*     ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin) *)

(*   (** *) *)
(* (*    * Add Proposal *) *)
(* (*    * *) *)
(* (*    * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code. *) *)
(* (*    * *) *)
(* (*    * @param beneficiary who to send the ether to *) *)
(* (*    * @param weiAmount amount of ether to send, in wei *) *)
(* (*    * @param jobDescription Description of job *) *)
(* (*    * @param transactionBytecode bytecode of transaction *) *)
(* (*    *) *)
(*   public fun newProposal ( *)
(*         beneficiary : address, *)
(*         weiAmount : uint, *)
(*         jobDescription : string, *)
(*         transactionBytecode : bytes *)
(*     ) *)
(*         guardedby onlyMembers *)
(*         return uint = *)
(*     let proposalID = length proposals; *)
(*     push_back (proposals, { *)
(*       recipient = beneficiary, *)
(*       amount = weiAmount, *)
(*       description = jobDescription, *)
(*       proposalHash = keccak256(beneficiary, weiAmount, transactionBytecode), *)
(*       votingDeadline = now + debatingPeriodInMinutes * 1 minutes, *)
(*       executed = ref false, *)
(*       proposalPassed = ref false, *)
(*       numberOfVotes = ref 0, *)
(*       currentResult = ref 0, *)
(*     } : Proposal); *)
(*     ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription); *)
(*     numProposals := proposalID+1; *)
(*     proposalID *)

(*   (** *) *)
(* (*    * Add proposal in Ether *) *)
(* (*    * *) *)
(* (*    * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code. *) *)
(* (*    * This is a convenience function to use if the amount to be given is in round number of ether units. *) *)
(* (*    * *) *)
(* (*    * @param beneficiary who to send the ether to *) *)
(* (*    * @param etherAmount amount of ether to send *) *)
(* (*    * @param jobDescription Description of job *) *)
(* (*    * @param transactionBytecode bytecode of transaction *) *)
(* (*    *) *)
(*   public fun newProposalInEther ( *)
(*         beneficiary : address, *)
(*         etherAmount : uint, *)
(*         jobDescription : string, *)
(*         transactionBytecode : bytes *)
(*     ) *)
(*         guardedby onlyMembers *)
(*         return uint = *)
(*     newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode) *)

(*   (** *) *)
(* (*    * Check if a proposal code matches *) *)
(* (*    * *) *)
(* (*    * @param proposalNumber ID number of the proposal to query *) *)
(* (*    * @param beneficiary who to send the ether to *) *)
(* (*    * @param weiAmount amount of ether to send *) *)
(* (*    * @param transactionBytecode bytecode of transaction *) *)
(* (*    *) *)
(*  (* According to http://solidity.readthedocs.io/en/latest/miscellaneous.html#modifiers : *) *)
(* (*     pure for functions: Disallows modification or access of state - this is not enforced yet. *) *)
(* (*     view for functions: Disallows modification of state - this is not enforced yet. *) *)
(* (*     constant for state variables: Disallows assignment (except initialisation), does not occupy storage slot. *) *)
(* (*     constant for functions: Same as view. *) *)
(* (*   *) *)
(*   public fun checkProposalCode ( *)
(*         proposalNumber : uint, *)
(*         beneficiary : address, *)
(*         weiAmount : uint, *)
(*         transactionBytecode : bytes *)
(*     )  constant *)
(*         return bool = *)
(*     let storage p : Proposal = proposals[proposalNumber]; *)
(*     p.proposalHash = keccak256(beneficiary, weiAmount, transactionBytecode) *)

(*     fun validProposalNumber n = *)
(*       require (n < !!numProposals) *)
              
(*   (** *) *)
(* (*    * Log a vote for a proposal *) *)
(* (*    * *) *)
(* (*    * Vote `supportsProposal? in support of : against` proposal #`proposalNumber` *) *)
(* (*    * *) *)
(* (*    * @param proposalNumber number of proposal *) *)
(* (*    * @param supportsProposal either in favor or against it *) *)
(* (*    * @param justificationText optional justification text *) *)
(* (*    *) *)
(*   public fun vote ( *)
(*         proposalNumber : uint, *)
(*         supportsProposal : bool, *)
(*         justificationText : string *)
(*     ) *)
(*         guardedby *)
(*         return uint = *)
(*     onlyMembers (); *)
(*     validProposalNumber proposalNumber; *)
(*     let p = &proposals[proposalNumber];         (* Get the proposal *) *)
(*     require(not (deref p.voted[msg.sender]));         (* If has already voted, cancel *) *)
(*     &p.voted[msg.sender] ::= true;                    (* Set this voter as having voted *) *)
(*     (* modify p.numberOfVotes ++;                              (* Increase the number of votes *) *) *)
(*     (* if supportsProposal then                         (* If they support the proposal *) *) *)
(*     (*   modify p.currentResult inc                          (* Increase score *) *) *)
(*     (* else                                         (* If they don't *) *) *)
(*     (*   modify p.currentResult dec                          (* Decrease the score *) *) *)
(*     (* end; *) *)

(*     (* Create a log of this event *) *)
(*     Voted(proposalNumber,  supportsProposal, msg.sender, justificationText); *)
(*     !p.numberOfVotes *)

(*   (** *) *)
(* (*    * Finish vote *) *)
(* (*    * *) *)
(* (*    * Count the votes proposal #`proposalNumber` and execute it if approved *) *)
(* (*    * *) *)
(* (*    * @param proposalNumber proposal number *) *)
(* (*    * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it *) *)
(* (*    *) *)
(*   public fun executeProposal (proposalNumber : uint, transactionBytecode : bytes) = *)
(*     let storage p : Proposal = proposals[proposalNumber]; *)

(*     require(now > p.votingDeadline                                            (* If it is past the voting deadline *) *)
(*       && not p.executed                                                         (* and it has not already been executed *) *)
(*       && p.proposalHash = keccak256(p.recipient, p.amount, transactionBytecode)  (* and the supplied code matches the proposal *) *)
(*       && p.numberOfVotes >= minimumQuorum);                                  (* and a minimum quorum has been reached... *) *)

(*     (* ...then execute result *) *)

(*     if !p.currentResult > majorityMargin then *)
(*       (* Proposal passed; execute the transaction *) *)

(*       p.executed := true; (* Avoid recursive calling *) *)
(*       require(call_with_value (p.recipient, p.amount, transactionBytecode)); *)

(*       p.proposalPassed := true *)
(*     else *)
(*       (* Proposal failed *) *)
(*       p.proposalPassed := false *)
(*     end; *)

(*     (* Fire Events *) *)
(*     ProposalTallied(proposalNumber, !p.currentResult, !p.numberOfVotes, !p.proposalPassed) *)

end
