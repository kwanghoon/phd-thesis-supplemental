pragma etiml ^0.1

structure Pervasive = struct
  fun inc n = n + 1
  fun dec n = n - 1
  fun nat_inc {n : Nat} (n : nat {n}) = n #+ #1
  fun nat_dec {n : Nat | n >= 1} (n : nat {n}) = n #- #1
  fun addBy b a = a + b
  fun subBy b a = a - b
  fun orBy b a = a bit_or b
fun waste_time () = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
                                                                                              
fun for_ ['a] {m1 m2: Time} {m1' m2' start : Nat} {eend : Nat | start <= eend} (start : nat {start}, eend : nat {eend}, init : 'a, f : forall {i : Nat | start <= i /\ i < eend} using (m1, m1'), nat {i} * 'a -- m2, m2' --> 'a) return 'a using (m1+m2+3281.0)*$(eend-start)+4012.0, (m1'+m2'+52)*(eend-start)+50 =
  lets
    fun loop {i : Nat | start <= i /\ i <= eend} (i : nat {i}, acc : 'a) (* using (m1+m2) * $(eend-i), (m1'+m2') * (eend-i) *) =
      ifi i #>= eend then waste_time (); acc
      else
        %loop (i #+ #1, %f (i, acc)) using (m1+m2+3281.0) * $(eend-i)+1651.0, (m1'+m2'+52) * (eend-i)+16
      end
  in
    %loop (start, init)
  end
  
  fun require b = if b then waste_time (); () else (throw using _) end
  val assert = require
  fun unop_ref ['a] {m : Time} {m' : Nat} r (f : 'a -- m, m' --> 'a) = r := f !r
  val ether = 1000000000000000000
  val finney = 1000000000000000
  val minute = 60
  val hour = 60 * minute
  val day = 24 * hour
  fun truncate n v = v bit_and (2 ** (8*n) - 1)
  datatype some_nat = SomeNat {n : Nat | n < 2 ** 256} of nat {n} --> some_nat
  fun imin {a b : Nat} (a : nat {a}, b : nat {b}) return nat {a min b} =
    ifi a #<= b then a : nat {a min b} else b : nat {a min b} end
end

(**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 *)
contract Ownable = struct
  public state owner : cell address 

  (**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   *)
  fun init () =
    owner ::= msg.sender

  (**
   * @dev Throws if called by any account other than the owner.
   *)
  fun onlyOwner () =
    require(msg.sender == !!owner)

  (**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   *)
  fun transferOwnership (newOwner : address) =
    onlyOwner ();
    if (newOwner != 0) then
      owner ::= newOwner
    end

end

(* @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens*)
(* @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)*)
interface ERC721 = sig
  (* Required methods*)
  public fun totalSupply () view return (total : uint256)
  public fun balanceOf (_owner : address) view return (balance : uint256)
  external fun ownerOf (_tokenId : uint256) view return (owner : address)
  external fun approve (_to : address, _tokenId : uint256)
  external fun transfer (_to : address, _tokenId : uint256)
  external fun transferFrom (_from : address, _to : address, _tokenId : uint256)

  (* Events*)
  event Transfer(from : address, to : address, tokenId : uint256)
  event Approval(owner : address, approved : address, tokenId : uint256)

  (* Optional*)
  (* public fun name () view return (name : string)*)
  (* public fun symbol () view return (symbol : string)*)
  (* external fun tokensOfOwner (_owner : address) view return (uint256[] tokenIds)*)
  (* public fun tokenMetadata (_tokenId : uint256, _preferredTransport : string) view return (infoUrl : string)*)

  (* ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)*)
  external fun supportsInterface (_interfaceID : bytes4) view return bool
end

(* // Auction wrapper funs*)

(* Auction wrapper funs*)

(* @title SEKRETOOOO*)
interface GeneScienceInterface = sig
  (* @dev simply a boolean to indicate this is the contract we expect to be*)
  public fun isGeneScience () pure return bool

  (* @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor*)
  (* @param genes1 genes of mom*)
  (* @param genes2 genes of sire*)
  (* @return the genes that are supposed to be passed down the child*)
  public fun mixGenes (genes1 : uint256, genes2 : uint256, targetBlock : uint256) return uint256
end

(* @title A facet of KittyCore that manages special access privileges.*)
(* @author Axiom Zen (https://www.axiomzen.co)*)
(* @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.*)
contract KittyAccessControl = struct
  (* This facet controls access control for CryptoKitties. There are four roles managed here:*)
  (**)
  (*   - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart*)
  (*     contracts. It is also the only role that can unpause the smart contract. It is initially*)
  (*     set to the address that created the smart contract in the KittyCore constructor.*)
  (**)
  (*   - The CFO: The CFO can withdraw funds from KittyCore and its auction contracts.*)
  (**)
  (*   - The COO: The COO can release gen0 kitties to auction, and mint promo cats.*)
  (**)
  (* It should be noted that these roles are distinct without overlap in their access abilities, the*)
  (* abilities listed for each role above are exhaustive. In particular, while the CEO can assign any*)
  (* address to any role, the CEO address itself doesn't have the ability to act in those roles. This*)
  (* restriction is intentional so that we aren't tempted to use the CEO address frequently out of*)
  (* convenience. The less we use an address, the less likely it is that we somehow compromise the*)
  (* account.*)

  (* @dev Emited when contract is upgraded - See README.md for updgrade plan*)
  event ContractUpgrade(newContract : address)

  (* The addresses of the accounts (or contracts) that can execute actions within each roles.*)
  public state ceoAddress : cell address 
  public state cfoAddress : cell address 
  public state cooAddress : cell address 

  (* @dev Keeps track whether the contract is paused. When that is true, most actions are blocked*)
  public state paused : cell bool = false

  (* @dev Access fun for CEO-only funality*)
  fun onlyCEO () =
    require(msg.sender == !!ceoAddress)

  (* @dev Access fun for CFO-only funality*)
  fun onlyCFO () =
    require(msg.sender == !!cfoAddress)

  (* @dev Access fun for COO-only funality*)
  fun onlyCOO () =
    require(msg.sender == !!cooAddress)

  fun onlyCLevel () =
    require(
      msg.sender == !!cooAddress ||
      msg.sender == !!ceoAddress ||
      msg.sender == !!cfoAddress
    )

  (* @dev Assigns a new address to act as the CEO. Only available to the current CEO.*)
  (* @param _newCEO The address of the new CEO*)
  external fun setCEO (_newCEO : address) =
    onlyCEO ();             
    require(_newCEO != 0);
    ceoAddress ::= _newCEO

  (* @dev Assigns a new address to act as the CFO. Only available to the current CEO.*)
  (* @param _newCFO The address of the new CFO*)
  external fun setCFO (_newCFO : address) =
    onlyCEO ();
    require(_newCFO != 0);
    cfoAddress ::= _newCFO

  (* @dev Assigns a new address to act as the COO. Only available to the current CEO.*)
  (* @param _newCOO The address of the new COO*)
  external fun setCOO (_newCOO : address) =
    onlyCEO ();
    require(_newCOO != 0);
    cooAddress ::= _newCOO

  (*** Pausable funality adapted from OpenZeppelin ***)

  (* @dev Modifier to allow actions only when the contract IS NOT paused*)
  fun whenNotPaused () =
    require(!!paused)

  (* @dev Modifier to allow actions only when the contract IS paused*)
  fun whenPaused () = 
    require(!!paused)

  (* @dev Called by any "C-level" role to pause the contract. Used only when*)
  (*  a bug or exploit is detected and we need to limit damage.*)
  external fun pause () =
    onlyCLevel ();
    whenNotPaused ();
    paused ::= true

  (* @dev Unpauses the smart contract. Can only be called by the CEO, since*)
  (*  one reason we may pause the contract is when CFO or COO accounts are*)
  (*  compromised.*)
  (* @notice This is public rather than external so it can be called by*)
  (*  derived contracts.*)
  public fun unpause () =
    onlyCEO ();
    whenPaused ();
    (* can't unpause if contract was upgraded*)
    paused ::= false

end

(* @title Base contract for CryptoKitties. Holds all common structs, events and base variables.*)
(* @author Axiom Zen (https://www.axiomzen.co)*)
(* @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.*)
contract KittyBase = struct

  open KittyAccessControl 

  (*** EVENTS ***)

  (* @dev The Birth event is fired whenever a new kitten comes into existence. This obviously*)
  (*  includes any time a cat is created through the giveBirth method, but it is also called*)
  (*  when a new gen0 cat is created.*)
  event Birth(owner : address, kittyId : uint256, matronId : uint256, sireId : uint256, genes : uint256)

  (* @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten*)
  (*  ownership is assigned, including births.*)
  event Transfer(from : address, to : address, tokenId : uint256)

  (*** DATA TYPES ***)

  (* @dev The main Kitty struct. Every cat in CryptoKitties is represented by a copy*)
  (*  of this structure, so great care was taken to ensure that it fits neatly into*)
  (*  exactly two 256-bit words. Note that the order of the members in this structure*)
  (*  is important because of the byte-packing rules used by Ethereum.*)
  (*  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html*)
  type Kitty = {
    (* The Kitty's genetic code is packed into these 256-bits, the format is*)
    (* sooper-sekret! A cat's genes never change.*)
    genes : uint256,

    (* The timestamp from the block when this cat came into existence.*)
    birthTime : uint64,

    (* The minimum timestamp after which this cat can engage in breeding*)
    (* activities again. This same timestamp is used for the pregnancy*)
    (* timer (for matrons) as well as the siring cooldown.*)
    cooldownEndBlock : uint64,

    (* The ID of the parents of this kitty, set to 0 for gen0 cats.*)
    (* Note that using 32-bit unsigned integers limits us to a "mere"*)
    (* 4 billion cats. This number might seem small until you realize*)
    (* that Ethereum currently has a limit of about 500 million*)
    (* transactions per year! So, this definitely won't be a problem*)
    (* for several years (even as Ethereum learns to scale).*)
    matronId : uint32,
    sireId : uint32,

    (* Set to the ID of the sire cat for matrons that are pregnant,*)
    (* zero otherwise. A non-zero value here is how we know a cat*)
    (* is pregnant. Used to retrieve the genetic material for the new*)
    (* kitten when the birth transpires.*)
    siringWithId : uint32,

    (* Set to the index in the cooldown array (see below) that represents*)
    (* the current cooldown duration for this Kitty. This starts at zero*)
    (* for gen0 cats, and is initialized to floor(generation/2) for others.*)
    (* Incremented by one for each successful breeding action, regardless*)
    (* of whether this cat is acting as matron or sire.*)
    cooldownIndex : uint16,

    (* The "generation number" of this cat. Cats minted by the CK contract*)
    (* for sale are called "gen0" and have a generation number of 0. The*)
    (* generation number of all other cats is the larger of the two generation*)
    (* numbers of their parents, plus one.*)
    (* (i.e. max(matron.generation, sire.generation) + 1)*)
    generation : uint16,
  }

  (*** CONSTANTS ***)

  (* @dev A lookup table indicating the cooldown duration after any successful*)
  (*  breeding action, called "pregnancy time" for matrons and "siring cooldown"*)
  (*  for sires. Designed such that the cooldown roughly doubles each time a cat*)
  (*  is bred, encouraging owners not to just keep breeding the same cat over*)
  (*  and over again. Caps out at one week (a cat can breed an unbounded number*)
  (*  of times, and the maximum cooldown is always seven days).*)
  public state cooldowns : vector uint32 = {
    minute,
    2 * minute,
    5 * minute,
    10 * minute,
    30 * minute,
    1 * hour,
    2 * hour,
    4 * hour,
    8 * hour,
    16 * hour,
    1 * day,
    2 * day,
    4 * day,
    7 * day,
  }

  (* An approximation of currently how many seconds are in between blocks.*)
  public state secondsPerBlock : cell uint256 = 15

  (*** STORAGE ***)

  (* @dev An array containing the Kitty struct for all Kitties in existence. The ID*)
  (*  of each cat is actually an index into this array. Note that ID 0 is a negacat,*)
  (*  the unKitty, the mythical beast that is the parent of all gen0 cats. A bizarre*)
  (*  creature that is both matron and sire... to itself! Has an invalid genetic code.*)
  (*  In other words, cat ID 0 is invalid... ;-)*)
  state kitties : map uint (* Kitty *){
    genes : uint256,
    birthTime : uint64,
    cooldownEndBlock : uint64,
    matronId : uint32,
    sireId : uint32,
    siringWithId : uint32,
    cooldownIndex : uint16,
    generation : uint16,
  }
  state numKitties : icell
                      
  fun copy_Kitty (t : storage Kitty, s : Kitty) =
    &t->genes ::= s.genes;
    &t->birthTime ::= s.birthTime;
    &t->cooldownEndBlock ::= s.cooldownEndBlock;
    &t->matronId ::= s.matronId;
    &t->sireId ::= s.sireId;
    &t->siringWithId ::= s.siringWithId;
    &t->cooldownIndex ::= s.cooldownIndex;
    &t->generation ::= s.generation

  (* @dev A mapping from cat IDs to the address that owns them. All cats have*)
  (*  some valid owner address, even gen0 cats are created with a non-zero owner.*)
  public state kittyIndexToOwner : map uint256 address

  (* @dev A mapping from owner address to count of tokens that address owns.*)
  (*  Used internally inside balanceOf() to resolve ownership count.*)
  state ownershipTokenCount : map address uint256

  (* @dev A mapping from KittyIDs to an address that has been approved to call*)
  (*  transferFrom(). Each Kitty can only have one approved address for transfer*)
  (*  at any time. A zero value means no approval is outstanding.*)
  public state kittyIndexToApproved : map uint256 address

  (* @dev A mapping from KittyIDs to an address that has been approved to use*)
  (*  this Kitty for siring via breedWith(). Each Kitty can only have one approved*)
  (*  address for siring at any time. A zero value means no approval is outstanding.*)
  public state sireAllowedToAddress : map uint256 address

  (* @dev The address of the ClockAuction contract that handles sales of Kitties. This*)
  (*  same contract handles both peer-to-peer sales as well as the gen0 sales which are*)
  (*  initiated every 15 minutes.*)
  public state saleAuction : cell address

  (* @dev The address of a custom ClockAuction subclassed contract that handles siring*)
  (*  auctions. Needs to be separate from saleAuction because the actions taken on success*)
  (*  after a sales and siring auction are quite different.*)
  public state siringAuction : cell address

  (* @dev Assigns ownership of a specific Kitty to an address.*)
  fun _transfer (_from : address, _to : address, _tokenId : uint256) internal =
    (* Since the number of kittens is capped to 2^32 we can't overflow this*)
    modify ownershipTokenCount[_to] ++;
    (* transfer ownership*)
    set kittyIndexToOwner[_tokenId] _to;
    (* When creating new kittens _from is 0x0, but we can't account that address.*)
    if (_from != 0) then
      modify ownershipTokenCount[_from] --;
      (* once the kitten is transferred also clear sire allowances*)
      set sireAllowedToAddress[_tokenId] 0;
      (* clear any previously approved ownership exchange*)
      set kittyIndexToApproved[_tokenId] 0
    end;
    (* Emit the transfer event.*)
    fire Transfer(_from, _to, _tokenId)

  (* @dev An internal method that creates a new kitty and stores it. This*)
  (*  method doesn't do any checking and should only be called when the*)
  (*  input data is known to be valid. Will generate both a Birth event*)
  (*  and a Transfer event.*)
  (* @param _matronId The kitty ID of the matron of this cat (zero for gen0)*)
  (* @param _sireId The kitty ID of the sire of this cat (zero for gen0)*)
  (* @param _generation The generation number of this cat, must be computed by caller.*)
  (* @param _genes The kitty's genetic code.*)
  (* @param _owner The inital owner of this cat, must be non-zero (except for the unKitty, ID 0)*)
  fun _createKitty {n : Nat} (
    _matronId : uint256,
    _sireId : uint256,
    _generation : uint256,
    _genes : uint256,
    _owner : address
  ) pre {numKitties : n} post {numKitties : n+1}
    internal
    return uint
  =
    (* These requires are not strictly necessary, our calling code should make*)
    (* sure that these conditions are never broken. However! _createKitty() is already*)
    (* an expensive call (for storage), and it doesn't hurt to be especially careful*)
    (* to ensure our data structures are always valid.*)
    require(_matronId == _matronId);
    require(_sireId == _sireId);
    require(_generation == _generation);

    (* New kitty starts with the same cooldown as parent gen/2*)
    let cooldownIndex : ref uint16 = ref (_generation / 2);
    if (!cooldownIndex > 13) then
      cooldownIndex := 13
    end;

    let _kitty = {
      genes = _genes,
      birthTime = now,
      cooldownEndBlock = 0,
      matronId = _matronId,
      sireId = _sireId,
      siringWithId = 0,
      cooldownIndex = !cooldownIndex,
      generation = _generation,
    } : Kitty;
    let newKittenId : uint256 = nat2int !!numKitties;
    copy_Kitty (&kitties->[newKittenId], _kitty);
    modify numKitties %nat_inc;
        
    (* It's probably never going to happen, 4 billion cats is A LOT, but*)
    (* let's just be 100% sure we never let this happen.*)
    require(newKittenId == truncate 4 newKittenId);

    (* emit the birth event*)
    fire Birth(
      _owner,
      newKittenId,
      _kitty.matronId,
      _kitty.sireId,
      _kitty.genes
    );

    (* This will assign ownership, and also emit the Transfer event as*)
    (* per ERC721 draft*)
    _transfer(0, _owner, newKittenId);

    newKittenId

  (* Any C-level can fix how many seconds per blocks are currently observed.*)
  external fun setSecondsPerBlock (secs : uint256) pre {cooldowns : 14} =
    onlyCLevel ();
    require(secs < cooldowns[#0]);
    secondsPerBlock ::= secs

end

(* @title The external contract that is responsible for generating metadata for the kitties,*)
(*  it has one fun that will return the data as bytes.*)
contract ERC721Metadata = struct
  (* @dev Given a token Id, return a byte array that is supposed to be converted into string.*)
  public fun getMetadata {n : Nat} (_tokenId : uint256, _: string {n}) view return (buffer : array bytes32 {4}, count : uint256) =
    let buffer : array bytes32 {4} = new_array (#4, 0);
    let count = ref 0;
    if (_tokenId == 1) then
      array_set (buffer, #0, short_str "Hello World! :D");
      count := 15
    elseif (_tokenId == 2) then
      array_set (buffer, #0, short_str "I would definitely choose a medi");
      array_set (buffer, #1, short_str "um length string.");
      count := 49
    elseif (_tokenId == 3) then
      array_set (buffer, #0, short_str "Lorem ipsum dolor sit amet, mi e");
      array_set (buffer, #1, short_str "st accumsan dapibus augue lorem,");
      array_set (buffer, #2, short_str " tristique vestibulum id, libero");
      array_set (buffer, #3, short_str " suscipit varius sapien aliquam.");
      count := 128
    end;
    (buffer, !count)

end

(* @title The facet of the CryptoKitties core contract that manages ownership, ERC-721 (draft) compliant.*)
(* @author Axiom Zen (https://www.axiomzen.co)*)
(* @dev Ref: https://github.com/ethereum/EIPs/issues/721*)
(*  See the KittyCore contract documentation to understand how the various contract facets are arranged.*)
contract KittyOwnership = struct inherit KittyBase

  (* @notice Name and symbol of the non fungible token, as defined in ERC721.*)
  public val name = "CryptoKitties"
  public val symbol = "CK"

  (* The contract that will return kitty metadata*)
  public state erc721Metadata : cell address

  val InterfaceSignature_ERC165 : bytes4 =
    truncate 4 (keccak256("supportsInterface(bytes4)"))

  val InterfaceSignature_ERC721 : bytes4 =
    truncate 4 (keccak256("name()")) bit_xor
    truncate 4 (keccak256("symbol()")) bit_xor
    truncate 4 (keccak256("totalSupply()")) bit_xor
    truncate 4 (keccak256("balanceOf(address)")) bit_xor
    truncate 4 (keccak256("ownerOf(uint256)")) bit_xor
    truncate 4 (keccak256("approve(address,uint256)")) bit_xor
    truncate 4 (keccak256("transfer(address,uint256)")) bit_xor
    truncate 4 (keccak256("transferFrom(address,address,uint256)")) bit_xor
    truncate 4 (keccak256("tokensOfOwner(address)")) bit_xor
    truncate 4 (keccak256("tokenMetadata(uint256,string)"))

  (* @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).*)
  (*  Returns true for any standardized interfaces implemented by this contract. We implement*)
  (*  ERC-165 (obviously!) and ERC-721.*)
  external fun supportsInterface (_interfaceID : bytes4) view return bool =
    (* DEBUG ONLY*)
    (*require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));*)

    ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721))

  (* @dev Set the address of the sibling contract that tracks metadata.*)
  (*  CEO only.*)
  public fun setMetadataAddress (_contractAddress : address) =
    onlyCEO ();
    erc721Metadata ::= _contractAddress

  (* Internal utility funs: These funs all assume that their input arguments*)
  (* are valid. We leave it to public methods to sanitize their inputs and follow*)
  (* the required logic.*)

  (* @dev Checks if a given address is the current owner of a particular Kitty.*)
  (* @param _claimant the address we are validating against.*)
  (* @param _tokenId kitten id, only valid when > 0*)
  fun _owns (_claimant : address, _tokenId : uint256) internal view return bool =
    kittyIndexToOwner[_tokenId] == _claimant

  (* @dev Checks if a given address currently has transferApproval for a particular Kitty.*)
  (* @param _claimant the address we are confirming kitten is approved for.*)
  (* @param _tokenId kitten id, only valid when > 0*)
  fun _approvedFor (_claimant : address, _tokenId : uint256) internal view return bool =
    kittyIndexToApproved[_tokenId] == _claimant

  (* @dev Marks an address as being approved for transferFrom(), overwriting any previous*)
  (*  approval. Setting _approved to address(0) clears all transfer approval.*)
  (*  NOTE: _approve() does NOT send the Approval event. This is intentional because*)
  (*  _approve() and transferFrom() are used together for putting Kitties on auction, and*)
  (*  there is no value in spamming the log with Approval events in that case.*)
  fun _approve (_tokenId : uint256, _approved : address) internal =
    set kittyIndexToApproved[_tokenId] _approved

  (* @notice Returns the number of Kitties owned by a specific address.*)
  (* @param _owner The owner address to check.*)
  (* @dev Required for ERC-721 compliance*)
  public fun balanceOf (_owner : address) view return (count : uint256) =
    ownershipTokenCount[_owner]

  (* @notice Transfers a Kitty to another address. If transferring to a smart*)
  (*  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or*)
  (*  CryptoKitties specifically) or your Kitty may be lost forever. Seriously.*)
  (* @param _to The address of the recipient, can be a user or contract.*)
  (* @param _tokenId The ID of the Kitty to transfer.*)
  (* @dev Required for ERC-721 compliance.*)
  external fun transfer (
    _to : address,
    _tokenId : uint256 
  )    
  =
    whenNotPaused ();
    (* Safety check to prevent against an unexpected 0x0 default.*)
    require(_to <> 0);
    (* Disallow transfers to this contract to prevent accidental misuse.*)
    (* The contract should never own any kitties (except very briefly*)
    (* after a gen0 cat is created and before it goes on auction).*)
    require(_to <> this);
    (* Disallow transfers to the auction contracts to prevent accidental*)
    (* misuse. Auction contracts should only take ownership of kitties*)
    (* through the allow + transferFrom flow.*)
    require(_to <> !!saleAuction);
    require(_to <> !!siringAuction);

    (* You can only send your own cat.*)
    require(_owns(msg.sender, _tokenId));

    (* Reassign ownership, clear pending approvals, emit Transfer event.*)
    _transfer(msg.sender, _to, _tokenId)

  (* @notice Grant another address the right to transfer a specific Kitty via*)
  (*  transferFrom(). This is the preferred flow for transfering NFTs to contracts.*)
  (* @param _to The address to be granted transfer approval. Pass address(0) to*)
  (*  clear all approvals.*)
  (* @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.*)
  (* @dev Required for ERC-721 compliance.*)
  external fun approve (
    _to : address,
    _tokenId : uint256
  )
  =
    whenNotPaused ();
    (* Only an owner can grant transfer approval.*)
    require(_owns(msg.sender, _tokenId));

    (* Register the approval (replacing any previous approval).*)
    _approve(_tokenId, _to);

    (* Emit approval event.*)
    fire Approval(msg.sender, _to, _tokenId)

  (* @notice Transfer a Kitty owned by another address, for which the calling address*)
  (*  has previously been granted transfer approval by the owner.*)
  (* @param _from The address that owns the Kitty to be transfered.*)
  (* @param _to The address that should take ownership of the Kitty. Can be any address,*)
  (*  including the caller.*)
  (* @param _tokenId The ID of the Kitty to be transferred.*)
  (* @dev Required for ERC-721 compliance.*)
  external fun transferFrom (
    _from : address,
    _to : address,
    _tokenId : uint256
  )
  =
    whenNotPaused ();
    (* Safety check to prevent against an unexpected 0x0 default.*)
    require(_to <> 0);
    (* Disallow transfers to this contract to prevent accidental misuse.*)
    (* The contract should never own any kitties (except very briefly*)
    (* after a gen0 cat is created and before it goes on auction).*)
    require(_to <> this);
    (* Check for approval and valid ownership*)
    require(_approvedFor(msg.sender, _tokenId));
    require(_owns(_from, _tokenId));

    (* Reassign ownership (also clears pending approvals and emits Transfer event).*)
    _transfer(_from, _to, _tokenId)

  (* @notice Returns the total number of Kitties currently in existence.*)
  (* @dev Required for ERC-721 compliance.*)
  public fun totalSupply {n : Nat | n > 0} () view pre {numKitties : n} =
    !!numKitties #- #1 (* because Kitty 0 is invalid *)

  (* @notice Returns the address currently assigned ownership of a given Kitty.*)
  (* @dev Required for ERC-721 compliance.*)
  fun ownerOf (_tokenId : uint256)
    external
    view
    return (owner : address)
  =
    let owner : address = kittyIndexToOwner[_tokenId];
    require(owner <> 0);
    owner

  datatype some_array 'a = SomeArray {n : Nat} of array 'a {n} --> some_array 'a
      
  (* @notice Returns a list of all Kitty IDs assigned to an address.*)
  (* @param _owner The owner whose Kitties we are interested in.*)
  (* @dev This method MUST NEVER be called by smart contract code. First, it's fairly*)
  (*  expensive (it walks the entire Kitty array looking for cats belonging to owner),*)
  (*  but it also return a dynamic array, which is only supported for web3 calls, and*)
  (*  not contract-to-contract calls.*)
  external fun tokensOfOwner {len : Nat | len > 0} (_owner : address) view pre {numKitties : len} return (ownerTokens : some_array uint256) =
    let tokenCount : uint256 = balanceOf(_owner);

    lets (* return using $(5601+59*(len-1)), 78+len-1 *)
      val @SomeNat {n} n = int2nat tokenCount
    in
      ifi (n #= #0) then
        (* Return an empty array*)
        SomeArray empty_array
      else
        let totalCats = %totalSupply();
        let n = %imin (n, totalCats);
        let result = new_array (n, 0) using $(141+60*(len-1)), len;
        let resultIndex : ref uint256 = ref 0;

        (* We count on the fact that all cats have IDs starting at 1 and increasing*)
        (* sequentially up to the totalCat count. *)
        (* for (catId : uint256 = 1; catId <= totalCats; ++) *)
        (*   if (kittyIndexToOwner[catId] == _owner) then *)
        (*     set result[resultIndex] catId; *)
        (*     modify resultIndex ++ *)
        (*   end *)
        (* end; *)
        %for_ (#1, totalCats #+ #1, (), fn {i | 1 <= i /\ i < len} (catId : nat {i}, ()) => 
          let catId = nat2int catId;
          if (kittyIndexToOwner[catId] == _owner) then
            lets
              val @SomeNat {_} index = int2nat !resultIndex
            in
              array_set(result, index imod n, catId)
            end;
            %unop_ref resultIndex ++
          end
        );

        SomeArray result
      end
    end

  (* (* @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)*) *)
  (* (*  This method is licenced under the Apache License.*) *)
  (* (*  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol*) *)
  (* fun _memcpy {_len : Nat} (_dest : uint, _src : uint, _len : nat {_len}) private view = *)
  (*   () *)
  (*   (* Copy word-length chunks while possible*) *)
  (*   (* for (_len = _len; _len >= 32; -= 32) *) *)
  (*   (*   assembly { *) *)
  (*   (*     mstore(_dest, mload(_src)) *) *)
  (*   (*   }; *) *)
  (*   (*   modify _dest += 32; *) *)
  (*   (*   modify _src += 32 *) *)
  (*   (* end; *) *)

  (*   (* Copy remaining bytes*) *)
  (*   (* let mask : uint256 = 256 ** (32 - _len) - 1 *) *)
  (*   (* assembly { *) *)
  (*   (*   srcpart := and(mload(_src), not(mask)); *) *)
  (*   (*   destpart := and(mload(_dest), mask); *) *)
  (*   (*   mstore(_dest, or(destpart, srcpart)) *) *)
  (*   (* } *) *)

  (* (* @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)*) *)
  (* (*  This method is licenced under the Apache License.*) *)
  (* (*  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol*) *)
  (* fun _toString {n : Nat} (_rawBytes : array bytes32 {4}, _stringLength : nat {n}) private view return string {n} = *)
  (*   let outputString = %new_string _stringLength; *)
  (*   let outputPtr : uint256 = 0; *)
  (*   let bytesPtr : uint256 = 0; *)

  (*   (* assembly { *) *)
  (*   (*   outputPtr := add(outputString, 32); *) *)
  (*   (*   bytesPtr := _rawBytes *) *)
  (*   (* }; *) *)

  (*   %_memcpy(outputPtr, bytesPtr, _stringLength); *)

  (*   outputString *)

  (* fun new_string {n : Nat} (len : nat {n}) return string {n} = new_array (len, int2byte 0) *)
  (* datatype some_string = SomeString {n : Nat} of string {n} --> some_string *)
      
  (* @notice Returns a URI pointing to a metadata package for this token conforming to*)
  (*  ERC-721 (https://github.com/ethereum/EIPs/issues/721)*)
  (* @param _tokenId The ID number of the Kitty whose metadata should be returned.*)
  (* PW: currently our string cell is 256-bit wide, same as arrays, so instead of using 'some_string' for 'infoUrl' we'll just use 'some_array'. In the future when strings become 8-bit wide, we'll have a 'array2string' function which doesn't change the content and only multiply the length value by 32. *)
  external fun tokenMetadata {n : Nat} (_tokenId : uint256, _preferredTransport : string {n}) view return (infoUrl : some_array uint256) =
    require(!!erc721Metadata <> 0);
    let (buffer, count) = call (new_array (#4, 0), 0) erc721Metadata getMetadata(_tokenId, _preferredTransport);

    (* SomeString (%_toString(buffer, count)) *)
    require(count=4*32);
    SomeArray buffer

end



(* @title A facet of KittyCore that manages Kitty siring, gestation, and birth.*)
(* @author Axiom Zen (https://www.axiomzen.co)*)
(* @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.*)
contract KittyBreeding = struct inherit KittyOwnership

  (* @dev The Pregnant event is fired when two cats successfully breed and the pregnancy*)
  (*  timer begins for the matron.*)
  event Pregnant(owner : address, matronId : uint256, sireId : uint256, cooldownEndBlock : uint256)

  (* @notice The minimum payment required to use breedWithAuto(). This fee goes towards*)
  (*  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by*)
  (*  the COO role as the gas price changes.*)
  public state autoBirthFee : cell uint256 = 2 * finney

  (* Keeps track of number of pregnant kitties.*)
  public state pregnantKitties : cell uint256

  (* @dev The address of the sibling contract that is used to implement the sooper-sekret*)
  (*  genetic combination algorithm.*)
  public state geneScience : cell address

  (* @dev Update the address of the genetic contract, can only be called by the CEO.*)
  (* @param _address An address of a GeneScience contract instance to be used from this point forward.*)
  external fun setGeneScienceAddress (_address : address) =
    onlyCEO ();
    let candidateContract = attach _address GeneScienceInterface;

    (* NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117*)
    require(call false candidateContract isGeneScience());

    (* Set the new contract address*)
    geneScience ::= _address

  (* @dev Check if a sire has authorized breeding with this matron. True if both sire*)
  (*  and matron have the same owner, or if the sire has given siring permission to*)
  (*  the matron's owner (via approveSiring()).*)
  fun _isSiringPermitted (_sireId : uint256, _matronId : uint256) internal view return bool =
    let matronOwner : address = kittyIndexToOwner[_matronId];
    let sireOwner : address = kittyIndexToOwner[_sireId];

    (* Siring is okay if they have same owner, or if the matron's owner was given*)
    (* permission to breed with this sire.*)
    (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner)

  (* @dev Set the cooldownEndTime for the given Kitty, based on its current cooldownIndex.*)
  (*  Also increments the cooldownIndex (unless it has hit the cap).*)
  (* @param _kitten A reference to the Kitty in storage which needs its timer started.*)
  fun _triggerCooldown (_kitten : storage Kitty) internal pre {cooldowns : 14} =
    (* Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).*)
    lets
      val @SomeNat {n} n = int2nat (deref _kitten->cooldownIndex)
    in
      &_kitten->cooldownEndBlock ::= cooldowns[n imod #14]/!!secondsPerBlock + block.number
    end;

    (* Increment the breeding count, clamping it at 13, which is the length of the*)
    (* cooldowns array. We could check the array size dynamically, but hard-coding*)
    (* this as a constant saves gas. Yay, Solidity!*)
    if (deref _kitten->cooldownIndex < 13) then
      modify &_kitten->cooldownIndex += 1
    end

  (* @notice Grants approval to another user to sire with one of your Kitties.*)
  (* @param _addr The address that will be able to sire with your Kitty. Set to*)
  (*  address(0) to clear all siring approvals for this Kitty.*)
  (* @param _sireId A Kitty that you own that _addr will now be able to sire with.*)
  fun approveSiring (_addr : address, _sireId : uint256)
    external
  =
    whenNotPaused ();
    require(_owns(msg.sender, _sireId));
    set sireAllowedToAddress[_sireId] _addr

  (* @dev Updates the minimum payment required for calling giveBirthAuto(). Can only*)
  (*  be called by the COO address. (This fee is used to offset the gas cost incurred*)
  (*  by the autobirth daemon).*)
  external fun setAutoBirthFee (value : uint256) =
    onlyCOO ();
    autoBirthFee ::= value

  (* @dev Checks to see if a given Kitty is pregnant and (if so) if the gestation*)
  (*  period has passed.*)
  fun _isReadyToGiveBirth (_matron : storage Kitty) private view return bool =
    (deref _matron->siringWithId <> 0) && (deref _matron->cooldownEndBlock <= block.number)

  (* @dev Checks that a given kitten is able to breed. Requires that the*)
  (*  current cooldown is finished (for sires) and also checks that there is*)
  (*  no pending pregnancy.*)
  fun _isReadyToBreed (_kit : storage Kitty) internal view return bool =
    (* In addition to checking the cooldownEndBlock, we also need to check to see if*)
    (* the cat has a pending birth; there can be some period of time between the end*)
    (* of the pregnacy timer and the birth event.*)
    (deref _kit->siringWithId == 0) && (deref _kit->cooldownEndBlock <= block.number)

  (* @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or*)
  (*  in the middle of a siring cooldown).*)
  (* @param _kittyId reference the id of the kitten, any user can inquire about it*)
  fun isReadyToBreed (_kittyId : uint256)
    public
    view
    return bool
  =
    require(_kittyId > 0);
    let kit = &kitties->[_kittyId];
    _isReadyToBreed(kit)

  (* @dev Checks whether a kitty is currently pregnant.*)
  (* @param _kittyId reference the id of the kitten, any user can inquire about it*)
  fun isPregnant (_kittyId : uint256)
    public
    view
    return bool
  =
    require(_kittyId > 0);
    (* A kitty is pregnant if and only if this field is set*)
    deref kitties->[_kittyId]->siringWithId <> 0

  (* @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT*)
  (*  check ownership permissions (that is up to the caller).*)
  (* @param _matron A reference to the Kitty struct of the potential matron.*)
  (* @param _matronId The matron's ID.*)
  (* @param _sire A reference to the Kitty struct of the potential sire.*)
  (* @param _sireId The sire's ID*)
  fun _isValidMatingPair (
    _matron : storage Kitty,
    _matronId : uint256,
    _sire : storage Kitty,
    _sireId : uint256 
  )
    private
    view
    return bool
  =
    (* A Kitty can't breed with itself!*)
    if (_matronId == _sireId) then
      false

    (* Kitties can't breed with their parents.*)
    elseif (deref _matron->matronId == _sireId || deref _matron->sireId == _sireId) then
      false
    elseif (deref _sire->matronId == _matronId || deref _sire->sireId == _matronId) then
      false

    (* We can short circuit the sibling check (below) if either cat is*)
    (* gen zero (has a matron ID of zero).*)
    elseif (deref _sire->matronId == 0 || deref _matron->matronId == 0) then
      true (* PW: trailing semicolon is OK *)

    (* Kitties can't breed with full or half siblings.*)
    elseif (deref _sire->matronId == deref _matron->matronId || deref _sire->matronId == deref _matron->sireId) then
      false
    elseif (deref _sire->sireId == deref _matron->matronId || deref _sire->sireId == deref _matron->sireId) then
      false
    else
      (* Everything seems cool! Let's get DTF.*)
      true
    end

  (* @dev Internal check to see if a given sire and matron are a valid mating pair for*)
  (*  breeding via auction (i.e. skips ownership and siring approval checks).*)
  fun _canBreedWithViaAuction (_matronId : uint256, _sireId : uint256)
    internal
    view
    return bool
  =
    let matron = &kitties->[_matronId];
    let sire = &kitties->[_sireId];
    _isValidMatingPair(matron, _matronId, sire, _sireId)

  (* @notice Checks to see if two cats can breed together, including checks for*)
  (*  ownership and siring approvals. Does NOT check that both cats are ready for*)
  (*  breeding (i.e. breedWith could still fail until the cooldowns are finished).*)
  (*  TODO: Shouldn't this check pregnancy and cooldowns?!?*)
  (* @param _matronId The ID of the proposed matron.*)
  (* @param _sireId The ID of the proposed sire.*)
  fun canBreedWith (_matronId : uint256, _sireId : uint256)
    external
    view
    return bool
  =
    require(_matronId > 0);
    require(_sireId > 0);
    let matron = &kitties->[_matronId];
    let sire = &kitties->[_sireId];
    _isValidMatingPair(matron, _matronId, sire, _sireId) &&
      _isSiringPermitted(_sireId, _matronId)

  (* @dev Internal utility fun to initiate breeding, assumes that all breeding*)
  (*  requirements have been checked.*)
  fun _breedWith (_matronId : uint256, _sireId : uint256) internal pre {cooldowns : 14} =
    (* Grab a reference to the Kitties from storage.*)
    let sire = &kitties->[_sireId];
    let matron = &kitties->[_matronId];

    (* Mark the matron as pregnant, keeping track of who the sire is.*)
    &matron->siringWithId ::= _sireId;

    (* Trigger the cooldown for both parents.*)
    _triggerCooldown(sire);
    _triggerCooldown(matron);

    (* Clear siring permission for both parents. This may not be strictly necessary*)
    (* but it's likely to avoid confusion!*)
    set sireAllowedToAddress[_matronId] 0;
    set sireAllowedToAddress[_sireId] 0;

    (* Every time a kitty gets pregnant, counter is incremented.*)
    modify pregnantKitties ++;

    (* Emit the pregnancy event.*)
    fire Pregnant(kittyIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock.v)

  (* @notice Breed a Kitty you own (as matron) with a sire that you own, or for which you*)
  (*  have previously been given Siring approval. Will either make your cat pregnant, or will*)
  (*  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()*)
  (* @param _matronId The ID of the Kitty acting as matron (will end up pregnant if successful)*)
  (* @param _sireId The ID of the Kitty acting as sire (will begin its siring cooldown if successful)*)
  fun breedWithAuto (_matronId : uint256, _sireId : uint256)
    external
    payable
    pre {cooldowns : 14}
  =
    whenNotPaused ();
    (* Checks for payment.*)
    require(msg.value >= !!autoBirthFee);

    (* Caller must own the matron.*)
    require(_owns(msg.sender, _matronId));

    (* Neither sire nor matron are allowed to be on auction during a normal*)
    (* breeding operation, but we don't need to check that explicitly.*)
    (* For matron: The caller of this fun can't be the owner of the matron*)
    (*   because the owner of a Kitty on auction is the auction house, and the*)
    (*   auction house will never call breedWith().*)
    (* For sire: Similarly, a sire on auction will be owned by the auction house*)
    (*   and the act of transferring ownership will have cleared any oustanding*)
    (*   siring approval.*)
    (* Thus we don't need to spend gas explicitly checking to see if either cat*)
    (* is on auction.*)

    (* Check that matron and sire are both owned by caller, or that the sire*)
    (* has given siring permission to caller (i.e. matron's owner).*)
    (* Will fail for _sireId = 0*)
    require(_isSiringPermitted(_sireId, _matronId));

    (* Grab a reference to the potential matron*)
    let matron = &kitties->[_matronId];

    (* Make sure matron isn't pregnant, or in the middle of a siring cooldown*)
    require(_isReadyToBreed(matron));

    (* Grab a reference to the potential sire*)
    let sire = &kitties->[_sireId];

    (* Make sure sire isn't pregnant, or in the middle of a siring cooldown*)
    require(_isReadyToBreed(sire));

    (* Test that these cats are a valid mating pair.*)
    require(_isValidMatingPair(
      matron,
      _matronId,
      sire,
      _sireId
    ));

    (* All checks passed, kitty gets pregnant!*)
    _breedWith(_matronId, _sireId)

  (* @notice Have a pregnant Kitty give birth!*)
  (* @param _matronId A Kitty ready to give birth.*)
  (* @return The Kitty ID of the new kitten.*)
  (* @dev Looks at a given Kitty and, if pregnant and if the gestation period has passed,*)
  (*  combines the genes of the two parents to create a new kitten. The new Kitty is assigned*)
  (*  to the current owner of the matron. Upon successful completion, both the matron and the*)
  (*  new kitten will be ready to breed again. Note that anyone can call this fun (if they*)
  (*  are willing to pay the gas!), but the new kitten always goes to the mother's owner.*)
  fun giveBirth {len : Nat} (_matronId : uint256)
    external
    return uint256
    pre {numKitties : len}
    post {numKitties : len+1}
  =
    whenNotPaused ();
    (* Grab a reference to the matron in storage.*)
    let matron = &kitties->[_matronId];

    (* Check that the matron is a valid cat.*)
    require(deref matron->birthTime <> 0);

    (* Check that the matron is pregnant, and that its time has come!*)
    require(_isReadyToGiveBirth(matron));

    (* Grab a reference to the sire in storage.*)
    let sireId : uint256 = deref matron->siringWithId;
    let sire = &kitties->[sireId];

    (* Determine the higher generation number of the two parents*)
    let parentGen : ref uint16 = ref (deref matron->generation);
    if (deref sire->generation > deref matron->generation) then
      parentGen := deref sire->generation
    end;

    (* Call the sooper-sekret gene mixing operation.*)
    let childGenes : uint256 = call 0 (attach geneScience GeneScienceInterface) mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock.v - 1);

    (* Make the new kitten!*)
    let owner : address = kittyIndexToOwner[_matronId];
    let kittenId : uint256 = %_createKitty(_matronId, deref matron->siringWithId, !parentGen + 1, childGenes, owner);

    (* Clear the reference to sire from the matron (REQUIRED! Having siringWithId*)
    (* set is what marks a matron as being pregnant.)*)
    &matron->siringWithId ::= 0;

    (* Every time a kitty gives birth counter is decremented.*)
    modify pregnantKitties --;

    (* Send the balance fee to the person who made birth happen.*)
    send msg.sender (autoBirthFee);

    (* return the new kitten's ID*)
    kittenId
  
end










(* @title Auction Core*)
(* @dev Contains models, variables, and internal methods for the auction.*)
(* @notice We omit a fallback fun to prevent accidental sends to this contract.*)
contract ClockAuctionBase = struct

  (* Represents an auction on an NFT*)
  type Auction = {
    (* Current owner of NFT*)
    seller : address,
    (* Price (in wei) at beginning of auction*)
    startingPrice : uint128,
    (* Price (in wei) at end of auction*)
    endingPrice : uint128,
    (* Duration (in seconds) of auction*)
    duration : uint64,
    (* Time when auction started*)
    (* NOTE: 0 if this auction has been concluded*)
    startedAt : uint64,
  }

  fun make_Auction (
      seller,
      startingPrice,
      endingPrice,
      duration,
      startedAt
  ) = {
      seller = seller,
      startingPrice = startingPrice,
      endingPrice = endingPrice,
      duration = duration,
      startedAt = startedAt,
      } : Auction
        
  fun copy_Auction (t : storage Auction, s : Auction) =
    &t->seller ::= s.seller;
    &t->startingPrice ::= s.startingPrice;
    &t->endingPrice ::= s.endingPrice;
    &t->duration ::= s.duration;
    &t->startedAt ::= s.startedAt

  (* Reference to contract tracking NFT ownership*)
  public state nonFungibleContract : cell address

  (* Cut owner takes on each auction, measured in basis points (1/100 of a percent).*)
  (* Values 0-10,000 map to 0%-100%*)
  public state ownerCut : cell uint256

  (* Map from token ID to their corresponding auction.*)
  state tokenIdToAuction : map uint256 (* Auction *){
    seller : address,
    startingPrice : uint128,
    endingPrice : uint128,
    duration : uint64,
    startedAt : uint64,
  }

  event AuctionCreated(tokenId : uint256, startingPrice : uint256, endingPrice : uint256, duration : uint256)
  event AuctionSuccessful(tokenId : uint256, totalPrice : uint256, winner : address)
  event AuctionCancelled(tokenId : uint256)

  (* @dev Returns true if the claimant owns the token.*)
  (* @param _claimant - Address claiming to own the token.*)
  (* @param _tokenId - ID of token whose ownership to verify.*)
  fun _owns (_claimant : address, _tokenId : uint256) internal view return bool =
    ((call 0 (attach nonFungibleContract ERC721) ownerOf(_tokenId)) == _claimant)

  (* @dev Escrows the NFT, assigning ownership to this contract.*)
  (* Throws if the escrow fails.*)
  (* @param _owner - Current owner address of token to escrow.*)
  (* @param _tokenId - ID of token whose approval to verify.*)
  fun _escrow (_owner : address, _tokenId : uint256) internal =
    (* it will throw if transfer fails*)
    call () (attach nonFungibleContract ERC721) transferFrom(_owner, this, _tokenId)

  (* @dev Transfers an NFT owned by this contract to another address.*)
  (* Returns true if the transfer succeeds.*)
  (* @param _receiver - Address to transfer NFT to.*)
  (* @param _tokenId - ID of token to transfer.*)
  fun _transfer (_receiver : address, _tokenId : uint256) internal =
    (* it will throw if transfer fails*)
    call () (attach nonFungibleContract ERC721) transfer(_receiver, _tokenId)

  (* @dev Adds an auction to the list of open auctions. Also fires the*)
  (*  AuctionCreated event.*)
  (* @param _tokenId The ID of the token to be put on auction.*)
  (* @param _auction Auction to add.*)
  fun _addAuction (_tokenId : uint256, _auction : Auction) internal =
    (* Require that all auctions have a duration of*)
    (* at least one minute. (Keeps our math from getting hairy!)*)
    require(_auction.duration >= minute);

    copy_Auction (&tokenIdToAuction->[_tokenId], _auction);

    fire AuctionCreated(
      uint256(_tokenId),
      uint256(_auction.startingPrice),
      uint256(_auction.endingPrice),
      uint256(_auction.duration)
    )

  (* @dev Removes an auction from the list of open auctions.*)
  (* @param _tokenId - ID of NFT on auction.*)
  fun _removeAuction (_tokenId : uint256) internal =
    copy_Auction (&tokenIdToAuction->[_tokenId], {
                   seller = 0,
                   startingPrice = 0,
                   endingPrice = 0,
                   duration = 0,
                   startedAt = 0,
                 })

  (* @dev Cancels an auction unconditionally.*)
  fun _cancelAuction (_tokenId : uint256, _seller : address) internal =
    _removeAuction(_tokenId);
    _transfer(_seller, _tokenId);
    fire AuctionCancelled(_tokenId)

  (* @dev Returns true if the NFT is on auction.*)
  (* @param _auction - Auction to check.*)
  fun _isOnAuction (_auction : storage Auction) internal view return bool =
    (deref _auction->startedAt > 0)

  (* @dev Computes the current price of an auction. Factored out*)
  (*  from _currentPrice so we can run extensive unit tests.*)
  (*  When testing, make this fun public and turn on*)
  (*  `Current price computation` test suite.*)
  fun _computeCurrentPrice (
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256,
    _secondsPassed : uint256
  )
    internal
    pure
    return uint256
  =
    (* NOTE: We don't use SafeMath (or similar) in this fun because*)
    (*  all of our public funs carefully cap the maximum values for*)
    (*  time (at 64-bits) and currency (at 128-bits). _duration is*)
    (*  also known to be non-zero (see the require() statement in*)
    (*  _addAuction())*)
    if (_secondsPassed >= _duration) then
      (* We've reached the end of the dynamic pricing portion*)
      (* of the auction, just return the end price.*)
      _endingPrice
    else
      (* Starting price can be higher than ending price (and often is!), so*)
      (* this delta can be negative.*)
      let totalPriceChange : int256 = _endingPrice : int256 - _startingPrice;

      (* This multiplication can't overflow, _secondsPassed will easily fit within*)
      (* 64-bits, and totalPriceChange will easily fit within 128-bits, their product*)
      (* will always fit within 256-bits.*)
      let currentPriceChange : int256 = totalPriceChange * _secondsPassed : int256 / _duration;

      (* currentPriceChange can be negative, but if so, will have a magnitude*)
      (* less that _startingPrice. Thus, this result will always end up positive.*)
      let currentPrice : int256 = _startingPrice : int256 + currentPriceChange;

      currentPrice : uint256
    end

  (* @dev Returns current price of an NFT on auction. Broken into two*)
  (*  funs (this one, that computes the duration from the auction*)
  (*  structure, and the other that does the price computation) so we*)
  (*  can easily test that the price computation works correctly.*)
  fun _currentPrice (_auction : storage Auction)
    internal
    view
    return uint256
  =
    let secondsPassed : ref uint256 = ref 0;

    (* A bit of insurance against negative values (or wraparound).*)
    (* Probably not necessary (since Ethereum guarnatees that the*)
    (* now variable doesn't ever go backwards).*)
    if (now > deref _auction->startedAt) then
      secondsPassed := now - deref _auction->startedAt
    end;

    _computeCurrentPrice(
      deref _auction->startingPrice,
      deref _auction->endingPrice,
      deref _auction->duration,
      !secondsPassed
    )

  (* @dev Computes owner's cut of a sale.*)
  (* @param _price - Sale price of NFT.*)
  fun _computeCut (_price : uint256) internal view return uint256 =
    (* NOTE: We don't use SafeMath (or similar) in this fun because*)
    (*  all of our entry funs carefully cap the maximum values for*)
    (*  currency (at 128-bits), and ownerCut <= 10000 (see the require()*)
    (*  statement in the ClockAuction constructor). The result of this*)
    (*  fun is always guaranteed to be <= _price.*)
    _price * !!ownerCut / 10000

  (* @dev Computes the price and transfers winnings.*)
  (* Does NOT transfer ownership of token.*)
  fun _bid (_tokenId : uint256, _bidAmount : uint256)
    internal
    return uint256
  =
    (* Get a reference to the auction struct*)
    let auction = &tokenIdToAuction->[_tokenId];

    (* Explicitly check that this auction is currently live.*)
    (* (Because of how Ethereum mappings work, we can't just count*)
    (* on the lookup above failing. An invalid _tokenId will just*)
    (* return an auction object that is all zeros.)*)
    require(_isOnAuction(auction));

    (* Check that the bid is greater than or equal to the current price*)
    let price : uint256 = _currentPrice(auction);
    require(_bidAmount >= price);

    (* Grab a reference to the seller before the auction struct*)
    (* gets deleted.*)
    let seller : address = deref auction->seller;

    (* The bid is good! Remove the auction before sending the fees*)
    (* to the sender so we can't have a reentrancy attack.*)
    _removeAuction(_tokenId);

    (* Transfer proceeds to seller (if there are any!)*)
    if (price > 0) then
      (* Calculate the auctioneer's cut.*)
      (* (NOTE: _computeCut() is guaranteed to return a*)
      (* value <= price, so this subtraction can't go negative.)*)
      let auctioneerCut : uint256 = _computeCut(price);
      let sellerProceeds : uint256 = price - auctioneerCut;

      (* NOTE: Doing a transfer() in the middle of a complex*)
      (* method like this is generally discouraged because of*)
      (* reentrancy attacks and DoS attacks if the seller is*)
      (* a contract with an invalid fallback fun. We explicitly*)
      (* guard against reentrancy attacks by removing the auction*)
      (* before calling transfer(), and the only thing the seller*)
      (* can DoS is the sale of their own asset! (And if it's an*)
      (* accident, they can call cancelAuction(). )*)
      call_with_value () seller sellerProceeds
    end;

    (* Calculate any excess funds included with the bid. If the excess*)
    (* is anything worth worrying about, transfer it back to bidder.*)
    (* NOTE: We checked above that the bid amount is greater than or*)
    (* equal to the price so this cannot underflow.*)
    let bidExcess : uint256 = _bidAmount - price;

    (* Return the funds. Similar to the previous transfer, this is*)
    (* not susceptible to a re-entry attack because the auction is*)
    (* removed before any transfers occur.*)
    call_with_value () msg.sender.transfer bidExcess;

    (* Tell the world!*)
    fire AuctionSuccessful(_tokenId, price, msg.sender);

    price

end







(** *)
(*  * @title Pausable *)
(*  * @dev Base contract which allows children to implement an emergency stop mechanism. *)
(*  *)
contract Pausable = struct inherit Ownable
  event Pause()
  event Unpause()

  public val paused : ref bool = ref false


  (** *)
(*    * @dev fun to allow actions only when the contract IS paused *)
(*    *)
  fun whenNotPaused () =
    require(not !!paused)

  (** *)
(*    * @dev fun to allow actions only when the contract IS NOT paused *)
(*    *)
  fun whenPaused () =
    require(!!paused)

  (** *)
(*    * @dev called by the owner to pause, triggers stopped state *)
(*    *)
  fun pause () guard onlyOwner, whenNotPaused return bool =
    set paused true;
    fire Pause();
    true

  (** *)
(*    * @dev called by the owner to unpause, return to normal state *)
(*    *)
  fun unpause () return bool =
    onlyOwner (); whenPaused ();
    paused := false;
    fire Unpause();
    true

end


(* @title Clock auction for non-fungible tokens.*)
(* @notice We omit a fallback fun to prevent accidental sends to this contract.*)
contract ClockAuction = struct

  open Pausable
  open ClockAuctionBase
         
  (* @dev The ERC-165 interface signature for ERC-721.*)
  (*  Ref: https://github.com/ethereum/EIPs/issues/165*)
  (*  Ref: https://github.com/ethereum/EIPs/issues/721*)
  val InterfaceSignature_ERC721 : bytes4 = 0x9a20483d

  (* @dev Constructor creates a reference to the NFT ownership contract*)
  (*  and verifies the owner cut is in the valid range.*)
  (* @param _nftAddress - address of a deployed contract implementing*)
  (*  the Nonfungible Interface.*)
  (* @param _cut - percent cut the owner takes on each auction, must be*)
  (*  between 0-10,000.*)
  public fun init (_nftAddress : address, _cut : uint256) =
    require(_cut <= 10000);
    set ownerCut _cut;

    let candidateContract = attach _nftAddress ERC721;
    require(call false candidateContract supportsInterface(InterfaceSignature_ERC721));
    nonFungibleContract ::= _nftAddress

  (* @dev Remove all Ether from the contract, which is the owner's cuts*)
  (*  as well as any Ether sent directly to the contract address.*)
  (*  Always transfers to the NFT contract, but can be called either by*)
  (*  the owner or the NFT contract.*)
  external fun withdrawBalance () =
    let nftAddress : address = !!nonFungibleContract;

    require(
      msg.sender == !!owner ||
      msg.sender == nftAddress
    );
    (* We are using this boolean method to make sure that even if one fails it will still work*)
    let res : bool = send nftAddress (this.balance);
    res

  (* @dev Creates and begins a new auction.*)
  (* @param _tokenId - ID of token to auction, sender must be owner.*)
  (* @param _startingPrice - Price of item (in wei) at beginning of auction.*)
  (* @param _endingPrice - Price of item (in wei) at end of auction.*)
  (* @param _duration - Length of time to move between starting*)
  (*  price and ending price (in seconds).*)
  (* @param _seller - Seller, if not the message sender*)
  fun createAuction (
    _tokenId : uint256,
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256,
    _seller : address
  )
    external
  =
    whenNotPaused ();
    (* Sanity check that no inputs overflow how many bits we've allocated*)
    (* to store them in the auction struct.*)
    require(_startingPrice == _startingPrice : uint128);
    require(_endingPrice == _endingPrice : uint128);
    require(_duration == _duration : uint64);

    require(_owns(msg.sender, _tokenId));
    _escrow(msg.sender, _tokenId);
    let auction : Auction = make_Auction (
          _seller,
          _startingPrice,
          _endingPrice,
          _duration,
          now
        ) : Auction;
    _addAuction(_tokenId, auction)

  (* @dev Bids on an open auction, completing the auction and transferring*)
  (*  ownership of the NFT if enough Ether is supplied.*)
  (* @param _tokenId - ID of token to bid on.*)
  fun bid (_tokenId : uint256)
    external
    payable
  =
    whenNotPaused ();
    (* _bid will throw if the bid or funds transfer fails*)
    _bid(_tokenId, msg.value);
    _transfer(msg.sender, _tokenId)

  (* @dev Cancels an auction that hasn't been won yet.*)
  (*  Returns the NFT to original owner.*)
  (* @notice This is a state-modifying fun that can*)
  (*  be called while the contract is paused.*)
  (* @param _tokenId - ID of token on auction*)
  fun cancelAuction (_tokenId : uint256)
    external
  =
    let auction = &tokenIdToAuction->[_tokenId];
    require(_isOnAuction(auction));
    let seller : address = deref auction->seller;
    require(msg.sender == seller);
    _cancelAuction(_tokenId, seller)

  (* @dev Cancels an auction when the contract is paused.*)
  (*  Only the owner may do this, and NFTs are returned to*)
  (*  the seller. This should only be used in emergencies.*)
  (* @param _tokenId - ID of the NFT on auction to cancel.*)
  fun cancelAuctionWhenPaused (_tokenId : uint256)
    external
  =
    whenPaused (); onlyOwner ();
    let auction = &tokenIdToAuction->[_tokenId];
    require(_isOnAuction(auction));
    _cancelAuction(_tokenId, deref auction->seller)

  (* @dev Returns auction info for an NFT on auction.*)
  (* @param _tokenId - ID of NFT on auction.*)
  fun getAuction (_tokenId : uint256)
    external
    view
    return
  (
    seller : address,
    startingPrice : uint256,
    endingPrice : uint256,
    duration : uint256,
    startedAt : uint256
  ) =
    let auction = &tokenIdToAuction->[_tokenId];
    require(_isOnAuction(auction));
    (
      deref auction->seller,
      deref auction->startingPrice,
      deref auction->endingPrice,
      deref auction->duration,
      deref auction->startedAt
    )

  (* @dev Returns the current price of an auction.*)
  (* @param _tokenId - ID of the token price we are checking.*)
  fun getCurrentPrice (_tokenId : uint256)
    external
    view
    return uint256
  =
    let auction = &tokenIdToAuction->[_tokenId];
    require(_isOnAuction(auction));
    _currentPrice(auction)

end


(* @title Reverse auction modified for siring*)
(* @notice We omit a fallback fun to prevent accidental sends to this contract.*)
contract SiringClockAuction = struct inherit ClockAuction

  (* @dev Sanity check that allows us to ensure that we are pointing to the*)
  (*  right auction in our setSiringAuctionAddress() call.*)
  public val isSiringClockAuction : bool = true

  (* Delegate constructor*)
  public fun init (_nftAddr : address, _cut : uint256) =
    fire ClockAuction(_nftAddr, _cut)

  (* @dev Creates and begins a new auction. Since this fun is wrapped,*)
  (* require sender to be KittyCore contract.*)
  (* @param _tokenId - ID of token to auction, sender must be owner.*)
  (* @param _startingPrice - Price of item (in wei) at beginning of auction.*)
  (* @param _endingPrice - Price of item (in wei) at end of auction.*)
  (* @param _duration - Length of auction (in seconds).*)
  (* @param _seller - Seller, if not the message sender*)
  fun createAuction (
    _tokenId : uint256,
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256,
    _seller : address
  )
    external
  =
    (* Sanity check that no inputs overflow how many bits we've allocated*)
    (* to store them in the auction struct.*)
    require(_startingPrice == _startingPrice : uint128);
    require(_endingPrice == _endingPrice : uint128);
    require(_duration == _duration : uint64);

    require(msg.sender == !!nonFungibleContract);
    _escrow(_seller, _tokenId);
    let auction = make_Auction(
      _seller,
      _startingPrice,
      _endingPrice,
      _duration,
      now
        ) : Auction;
    _addAuction(_tokenId, auction)

  (* @dev Places a bid for siring. Requires the sender*)
  (* is the KittyCore contract because all bid methods*)
  (* should be wrapped. Also return the kitty to the*)
  (* seller rather than the winner.*)
  fun bid (_tokenId : uint256)
    external
    payable
  =
    require(msg.sender == !!nonFungibleContract);
    let seller : address = tokenIdToAuction[_tokenId].seller;
    (* _bid checks that token ID is valid and will throw if bid fails*)
    _bid(_tokenId, msg.value);
    (* We transfer the kitty back to the seller, the winner will get*)
    (* the offspring*)
    _transfer(seller, _tokenId)

end





(* @title Clock auction modified for sale of kitties*)
(* @notice We omit a fallback fun to prevent accidental sends to this contract.*)
contract SaleClockAuction = struct inherit ClockAuction

  (* @dev Sanity check that allows us to ensure that we are pointing to the*)
  (*  right auction in our setSaleAuctionAddress() call.*)
  public val isSaleClockAuction : bool = true

  (* Tracks last 5 sale price of gen0 kitty sales*)
  public state gen0SaleCount : cell uint256
  public state lastGen0SalePrices : vector uint256

  (* Delegate constructor*)
  public fun init (_nftAddr : address, _cut : uint256) =
    fire ClockAuction(_nftAddr, _cut)

  (* @dev Creates and begins a new auction.*)
  (* @param _tokenId - ID of token to auction, sender must be owner.*)
  (* @param _startingPrice - Price of item (in wei) at beginning of auction.*)
  (* @param _endingPrice - Price of item (in wei) at end of auction.*)
  (* @param _duration - Length of auction (in seconds).*)
  (* @param _seller - Seller, if not the message sender*)
  fun createAuction (
    _tokenId : uint256,
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256,
    _seller : address
  )
    external
  =
    (* Sanity check that no inputs overflow how many bits we've allocated*)
    (* to store them in the auction struct.*)
    require(_startingPrice == _startingPrice : uint128);
    require(_endingPrice == _endingPrice : uint128);
    require(_duration == _duration : uint64);

    require(msg.sender == !!nonFungibleContract);
    _escrow(_seller, _tokenId);
    let auction : Auction = make_Auction(
      _seller,
      _startingPrice,
      _endingPrice,
      _duration,
      now
    ) : Auction;
    _addAuction(_tokenId, auction)

  (* @dev Updates lastSalePrice if seller is the nft contract*)
  (* Otherwise, works the same as default bid method.*)
  fun bid (_tokenId : uint256)
    external
    payable
    pre {lastGen0SalePrices : 5}
  =
    (* _bid verifies token ID size*)
    let seller : address = tokenIdToAuction[_tokenId].seller;
    let price : uint256 = _bid(_tokenId, msg.value);
    _transfer(msg.sender, _tokenId);

    (* If not a gen0 auction, exit*)
    if (seller == !!nonFungibleContract) then
      (* Track gen0 sale prices*)
      lets
        val @SomeNat {n} n = int2nat (!!gen0SaleCount)
      in
        set lastGen0SalePrices[n imod #5] price
      end;
      modify gen0SaleCount ++
    end

(* PW: here is a limitation of TiML: it can't parametrize on states. MicroTiML actually supports it (for continuations), so TiML should support it too.  *)                              
fun for_lastGen0SalePrices ['a] {m1 m2: Time} {m1' m2' st start : Nat} {eend : Nat | start <= eend} (start : nat {start}, eend : nat {eend}, init : 'a, f : forall {i : Nat | start <= i /\ i < eend} using (m1, m1'), funtype {lastGen0SalePrices : st} nat {i} * 'a -- m2, m2' --> 'a) pre {lastGen0SalePrices : st} return 'a using (m1+m2+3281.0)*$(eend-start)+4012.0, (m1'+m2'+52)*(eend-start)+50 =
  lets
    fun loop {i : Nat | start <= i /\ i <= eend} (i : nat {i}, acc : 'a) pre {lastGen0SalePrices : st} (* using (m1+m2) * $(eend-i), (m1'+m2') * (eend-i) *) =
      ifi i #>= eend then waste_time (); acc
      else
        %loop (i #+ #1, %f (i, acc)) using (m1+m2+3281.0) * $(eend-i)+1651.0, (m1'+m2'+52) * (eend-i)+16
      end
  in
    %loop (start, init)
  end
  
  external fun averageGen0SalePrice () view pre {lastGen0SalePrices : 5} return uint256 =
    let sum : ref uint256 = ref 0;
    (* for (i : uint256 = 0; i < 5; ++) *)
    (*   modify sum += lastGen0SalePrices[i] *)
    (* end; *)
    %for_lastGen0SalePrices (#0, #5, (), fn {i | 0 <= i /\ i < 5} (i : nat {i}, ()) pre {lastGen0SalePrices : 5} => 
      %unop_ref sum (+= lastGen0SalePrices[i])
    );
    !sum / 5

end


(* @title Handles creating auctions for sale and siring of kitties.*)
(*  This wrapper of ReverseAuction exists only so that users can create*)
(*  auctions with only one transaction.*)
contract KittyAuction = struct inherit KittyBreeding

  (* @notice The auction contract variables are defined in KittyBase to allow*)
  (*  us to refer to them in KittyOwnership to prevent accidental transfers.*)
  (* `saleAuction` refers to the auction for gen0 and p2p sale of kitties.*)
  (* `siringAuction` refers to the auction for siring rights of kitties.*)

  (* @dev Sets the reference to the sale auction.*)
  (* @param _address - Address of sale contract.*)
  external fun setSaleAuctionAddress (_address : address) =
    onlyCEO ();
    let candidateContract = attach _address SaleClockAuction;

    (* NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117*)
    require(call false candidateContract isSaleClockAuction());

    (* Set the new contract address*)
    saleAuction ::= _address

  (* @dev Sets the reference to the siring auction.*)
  (* @param _address - Address of siring contract.*)
  external fun setSiringAuctionAddress (_address : address) =
    onlyCEO ();
    let candidateContract = attach _address SiringClockAuction;

    (* NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117*)
    require(call false candidateContract isSiringClockAuction());

    (* Set the new contract address*)
    siringAuction ::= _address

  (* @dev Put a kitty up for auction.*)
  (*  Does some ownership trickery to create auctions in one tx.*)
  fun createSaleAuction (
    _kittyId : uint256,
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256
  )
    external
  =
    whenNotPaused ();
    (* Auction contract checks input sizes*)
    (* If kitty is already on any auction, this will throw*)
    (* because it will be owned by the auction contract.*)
    require(_owns(msg.sender, _kittyId));
    (* Ensure the kitty is not pregnant to prevent the auction*)
    (* contract accidentally receiving ownership of the child.*)
    (* NOTE: the kitty IS allowed to be in a cooldown.*)
    require(not isPregnant(_kittyId));
    _approve(_kittyId, !!saleAuction);
    (* Sale auction throws if inputs are invalid and clears*)
    (* transfer and sire approval after escrowing the kitty.*)
    call () (attach !!saleAuction SaleClockAuction) createAuction(
      _kittyId,
      _startingPrice,
      _endingPrice,
      _duration,
      msg.sender
    )

  (* @dev Put a kitty up for auction to be sire.*)
  (*  Performs checks to ensure the kitty can be sired, then*)
  (*  delegates to reverse auction.*)
  fun createSiringAuction (
    _kittyId : uint256,
    _startingPrice : uint256,
    _endingPrice : uint256,
    _duration : uint256
  )
    external
  =
    whenNotPaused ();
    (* Auction contract checks input sizes*)
    (* If kitty is already on any auction, this will throw*)
    (* because it will be owned by the auction contract.*)
    require(_owns(msg.sender, _kittyId));
    require(isReadyToBreed(_kittyId));
    _approve(_kittyId, !!siringAuction);
    (* Siring auction throws if inputs are invalid and clears*)
    (* transfer and sire approval after escrowing the kitty.*)
    call () (attach siringAuction SiringClockAuction) createAuction(
      _kittyId,
      _startingPrice,
      _endingPrice,
      _duration,
      msg.sender
    )

  (* @dev Completes a siring auction by bidding.*)
  (*  Immediately breeds the winning matron with the sire on auction.*)
  (* @param _sireId - ID of the sire on auction.*)
  (* @param _matronId - ID of the matron owned by the bidder.*)
  fun bidOnSiringAuction (
    _sireId : uint256,
    _matronId : uint256
  )
    external
    payable
    pre {cooldowns : 14}
  =
    whenNotPaused ();
    (* Auction contract checks input sizes*)
    require(_owns(msg.sender, _matronId));
    require(isReadyToBreed(_matronId));
    require(_canBreedWithViaAuction(_matronId, _sireId));

    (* Define the current price of the auction.*)
    let currentPrice : uint256 = call 0 (attach siringAuction SiringClockAuction) getCurrentPrice(_sireId);
    require(msg.value >= currentPrice + !!autoBirthFee);

    (* Siring auction will throw if the bid fails.*)
    call_with_value () (attach siringAuction SiringClockAuction) bid (msg.value - autoBirthFee) (_sireId);
    _breedWith(_matronId, _sireId)

  (* @dev Transfers the balance of the sale auction contract*)
  (* to the KittyCore contract. We use two-step withdrawal to*)
  (* prevent two transfer calls in the auction bid fun.*)
  external fun withdrawAuctionBalances () =
    onlyCLevel ();
    call () (attach saleAuction SaleClockAuction).withdrawBalance();
    call () (attach siringAuction SiringClockAuction).withdrawBalance()

end


(* @title all funs related to creating kittens*)
contract KittyMinting = struct

  open KittyAuction

  (* Limits the number of cats the contract owner can ever create.*)
  public val PROMO_CREATION_LIMIT : uint256 = 5000
  public val GEN0_CREATION_LIMIT : uint256 = 45000

  (* Constants for gen0 auctions.*)
  public val GEN0_STARTING_PRICE : uint256 = 10 * finney
  public val GEN0_AUCTION_DURATION : uint256 = day

  (* Counts the number of cats the contract owner has created.*)
  public state promoCreatedCount : cell uint256
  public state gen0CreatedCount : cell uint256

  (* @dev we can create promo kittens, up to a limit. Only callable by COO*)
  (* @param _genes the encoded genes of the kitten to be created, any value is accepted*)
  (* @param _owner the future owner of the created kittens. Default to contract COO*)
  external fun createPromoKitty {len : Nat} (_genes : uint256, _owner : address) pre {numKitties : len} post {numKitties : len+1} =
    onlyCOO ();
    let kittyOwner : ref address = ref _owner;
    if (!kittyOwner ==0) then
       kittyOwner := !!cooAddress
    end;
    require(!!promoCreatedCount < PROMO_CREATION_LIMIT);

    modify promoCreatedCount ++;
    %_createKitty(0, 0, 0, _genes, !kittyOwner)

  (* @dev Computes the next gen0 auction starting price, given*)
  (*  the average of the past 5 prices + 50%.*)
  fun _computeNextGen0Price () internal view return uint256 =
    let avePrice : uint256 = call 0 (attach saleAuction SaleClockAuction) averageGen0SalePrice();

    (* Sanity check to ensure we don't overflow arithmetic*)
    require(avePrice == avePrice : uint128);

    let nextPrice : ref uint256 = ref (avePrice + (avePrice / 2));

    (* We never auction for less than starting price*)
    if (!nextPrice < GEN0_STARTING_PRICE) then
      nextPrice := GEN0_STARTING_PRICE
    end;

    !nextPrice

  (* @dev Creates a new gen0 kitty with the given genes and*)
  (*  creates an auction for it.*)
  external fun createGen0Auction {len : Nat} (_genes : uint256) pre {numKitties : len} post {numKitties : len+1} =
    onlyCOO ();
    require(!!gen0CreatedCount < GEN0_CREATION_LIMIT);

    let kittyId : uint256 = %_createKitty(0, 0, 0, _genes, this);
    _approve(kittyId, !!saleAuction);

    call () saleAuction createAuction(
      kittyId,
      _computeNextGen0Price(),
      0,
      GEN0_AUCTION_DURATION,
      this
    );

    modify gen0CreatedCount ++

end


(* @title CryptoKitties: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.*)
(* @author Axiom Zen (https://www.axiomzen.co)*)
(* @dev The main CryptoKitties contract, keeps track of kittens so they don't wander around and get lost.*)
contract KittyCore = struct inherit KittyMinting

  (* This is the main CryptoKitties contract. In order to keep our code seperated into logical sections,*)
  (* we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts*)
  (* that handle auctions and our super-top-secret genetic combination algorithm. The auctions are*)
  (* seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping*)
  (* them in their own contracts, we can upgrade them without disrupting the main contract that tracks*)
  (* kitty ownership. The genetic combination algorithm is kept seperate so we can open-source all of*)
  (* the rest of our code without making it _too_ easy for folks to figure out how the genetics work.*)
  (* Don't worry, I'm sure someone will reverse engineer it soon enough!*)
  (**)
  (* Secondly, we break the core contract into multiple files using inheritence, one for each major*)
  (* facet of funality of CK. This allows us to keep related code bundled together while still*)
  (* avoiding a single giant file with everything in it. The breakdown is as follows:*)
  (**)
  (*    - KittyBase: This is where we define the most fundamental code shared throughout the core*)
  (*       funality. This includes our main data storage, constants and data types, plus*)
  (*       internal funs for managing these items.*)
  (**)
  (*    - KittyAccessControl: This contract manages the various addresses and constraints for operations*)
  (*       that can be executed only by specific roles. Namely CEO, CFO and COO.*)
  (**)
  (*    - KittyOwnership: This provides the methods required for basic non-fungible token*)
  (*       transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).*)
  (**)
  (*    - KittyBreeding: This file contains the methods necessary to breed cats together, including*)
  (*       keeping track of siring offers, and relies on an external genetic combination contract.*)
  (**)
  (*    - KittyAuctions: Here we have the public methods for auctioning or bidding on cats or siring*)
  (*       services. The actual auction funality is handled in two sibling contracts (one*)
  (*       for sales and one for siring), while auction creation and bidding is mostly mediated*)
  (*       through this facet of the core contract.*)
  (**)
  (*    - KittyMinting: This final facet contains the funality we use for creating new gen0 cats.*)
  (*       We can make up to 5000 "promo" cats that can be given away (especially important when*)
  (*       the community is new), and all others can only be created and then immediately put up*)
  (*       for auction via an algorithmically determined starting price. Regardless of how they*)
  (*       are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the*)
  (*       community to breed, breed, breed!*)

  (* Set in case the core contract is broken and an upgrade is required*)
  public state newContractAddress : cell address

  (* @notice Creates the main CryptoKitties smart contract instance.*)
  public fun init () pre {numKitties : 0} post {numKitties : 1} =
    (* Starts paused.*)
    paused ::= true;

    (* the creator of the contract is the initial CEO*)
    ceoAddress ::= msg.sender;

    (* the creator of the contract is also the initial COO*)
    cooAddress ::= msg.sender;

    (* start with the mythical kitten 0 - so we don't have generation-0 parent issues*)
    %_createKitty(0, 0, 0, -1 : uint256, 0)

  (* @dev Used to mark the smart contract as upgraded, in case there is a serious*)
  (*  breaking bug. This method does nothing but keep track of the new contract and*)
  (*  emit a message indicating that the new address is set. It's up to clients of this*)
  (*  contract to update to the new contract address in that case. (This contract will*)
  (*  be paused indefinitely if such an upgrade takes place.)*)
  (* @param _v2Address new address*)
  external fun setNewAddress (_v2Address : address) guard onlyCEO, whenPaused =
    (* See README.md for updgrade plan*)
    newContractAddress ::= _v2Address;
    fire ContractUpgrade(_v2Address)

  (* @notice No tipping!*)
  (* @dev Reject all Ether from being sent here, unless it's from one of the*)
  (*  two auction contracts. (Hopefully, we can prevent user accidents.)*)
  fun default () external payable =
    require(
      msg.sender == !!saleAuction ||
      msg.sender == !!siringAuction
    )

  (* @notice Returns all the relevant information about a specific kitty.*)
  (* @param _id The ID of the kitty of interest.*)
  fun getKitty (_id : uint256)
    external
    view
    return (
    isGestating : bool,
    isReady : bool,
    cooldownIndex : uint256,
    nextActionAt : uint256,
    siringWithId : uint256,
    birthTime : uint256,
    matronId : uint256,
    sireId : uint256,
    generation : uint256,
    genes : uint256
  ) =
    let kit = &kitties->[_id];

    (* if this variable is 0 then it's not gestating*)
    (
      (deref kit->siringWithId <> 0),
      (deref kit->cooldownEndBlock <= block.number),
      (deref kit->cooldownIndex),
      (deref kit->cooldownEndBlock),
      (deref kit->siringWithId),
      (deref kit->birthTime),
      (deref kit->matronId),
      (deref kit->sireId),
      (deref kit->generation),
      (deref kit->genes)
    )

  (* @dev Override unpause so it requires all external contract addresses*)
  (*  to be set before contract can be unpaused. Also, we can't have*)
  (*  newContractAddress set either, because then the contract was upgraded.*)
  (* @notice This is public rather than external so we can call super.unpause*)
  (*  without using an expensive CALL.*)
  public fun unpause () =
    onlyCEO (); whenPaused ();
    require(!!saleAuction <> 0);
    require(!!siringAuction <> 0);
    require(!!geneScience <> 0);
    require(!!newContractAddress = 0);

    (* Actually unpause the contract.*)
    Pausable..unpause()

  (* @dev Allows the CFO to capture the balance available to the contract.*)
  external fun withdrawBalance () =
    onlyCFO ();
    let balance : uint256 = this_balance;
    (* Subtract all the currently pregnant kittens we have, plus 1 of margin.*)
    let subtractFees : uint256 = (!!pregnantKitties + 1) * !!autoBirthFee;

    if (balance > subtractFees) then
      send () cfoAddress (balance - subtractFees)
    else
      false
    end
  
end
