structure UnitTestBasic1 = struct

(* val x = 1 *)
(* val f = fn y => 1 + y *)
(* fun f y = 1 + y *)
(* val f = fn y => x + y *)
(* fun f y = x + y *)
(* val a = (f 64) using _ *)
(* val g = fn y => 1 + y *)
(* val b = f 64 *)
(* val b = a + 2 *)
(* val b = (a, 2) *)

(* val a = if __&false then 1 else 0 *)

(* val x = 1 *)
(* val f = fn {n : Nat} y => y + 1 *)
(* val f = fn {n : Nat} => (fn y => y + 1) using _ *)
(* val f = fn {n : Nat} y => x + y *)
(* fun f {n : Nat} y = y + 1 *)
(* fun f {n : Nat} y = x + y *)
(* val a = @f {1} *)
(* val b = a 1 *)
(* val a = @f {1} 1 *)

(* val x = 1 *)
(* val f = fn y => y *)
(* fun f y = y *)
(* val f = fn y => (x, y) *)
(* fun f y = (x, y) *)
(* val a = f 1 *)
(* val g = f *)

(* val f = fn y => 1 + y *)
(* val g = fn y => f y *)
(* val a = g 64 *)
          
(* datatype t2 'a = C {0 = 0} {1 = 1} of 'a --> t2 'a *)

(* val x = *)
(*     (let *)
(*       val (a, b) = (1, 2) *)
(*     in *)
(*       a *)
(*     end) using _ *)
    
(* val x = *)
(*     (let *)
(*       val (_, C (_, x)) = ((), C ((), 2)) *)
(*     in *)
(*       x *)
(*     end) using _ *)
    
(* val f = (fn (_, ()) => ()) using _ *)
(* fun f (_, ()) = () *)
(* val a = (f ((), ())) using _ *)

(* datatype t2 'a = C {0 = 0} {1 = 1} of 'a --> t2 'a *)

(* val f = fn ((), C ((), x)) => x : int *)
(* val a = (f ((), C ((), 2))) using _ *)
                            
(* val f = fn (_, C (_, x)) => x *)
(* val a = (f ((), C ((), 2))) using _ *)
                                                
(* val f = fn x => if x then 1 else 0 *)
(* fun f x = if x then 1 else 0 *)
(* val a = f __&false *)

(* datatype t = Fst | Snd *)
(* datatype t2 = C1 | C2 | C3 {n : Nat} {n = 0} of t --> t2 *)

(* val a = *)
(*     (let *)
(*       val x = @C3 {0} {_} Snd *)
(*     in *)
(*       (case x of *)
(*            C1 => 1 *)
(*          | C2 => 2 *)
(*          | C3 Fst => 31 *)
(*          | C3 Snd => 32) using _ *)
(*     end) using _ *)

(* val a = (case @C3 {0} {} Snd of *)
(*             C1 => 1 *)
(*           | C2 => 2 *)
(*           | C3 Fst => 31 *)
(*           | C3 Snd => 32) using _ *)

(* datatype t = C1 *)

(* val a = (case C1 of *)
(*             C1 => 1) using _ *)

(* val a = *)
(*     let *)
(*       val x = C1 using _ *)
(*     in *)
(*     (case x of *)
(*          C1 => 1) using _ *)
(*     end *)
                    
(* datatype t = C1 | C2 *)

(* val a = *)
(*     let *)
(*       val x = C2 using _ *)
(*     in *)
(*       (case x of *)
(*            C1 => 1 *)
(*          | C2 => 2) using _ *)
(*     end *)

(* val a = (case C2 of *)
(*             C1 => 1 *)
(*           | C2 => 2) using _ *)

(* val a = *)
(*     let *)
(*       val x = (C2, C2) *)
(*     in *)
(*       (case x of *)
(*            (_, C1) => 1 *)
(*          | (C1, C2) => 12 *)
(*          | (C2, C2) => 22) using _ *)
(*     end *)

(* val a = (case (C2, C2) of *)
(*             (_, C1) => 1 *)
(*           | (C1, C2) => 12 *)
(*           | (C2, C2) => 22) using _ *)

(* datatype t = C1 | C2 | C3 *)

(* val a = (case C3 of *)
(*             C1 => 1 *)
(*           | C2 => 2 *)
(*           | C3 => 3) using _ *)

(* datatype t = C1 | C2 | C3 | C4 *)

(* val a = (case C4 of *)
(*             C1 => 1 *)
(*           | C2 => 2 *)
(*           | C3 => 3 *)
(*           | C4 => 4) using _ *)

(* datatype list 'a : {Nat} = *)
(*          Nil of list 'a {0} *)
(*        | Nil2 of list 'a {0} *)
(*        | Cons {n : Nat} of 'a * list 'a {n} --> list 'a {n + 1} *)

(* val a = (case Cons (1, Nil) of *)
(*             Nil => 1 *)
(*           | Nil2 => 12 *)
(*           | Cons _ => 2) using _ *)

(* fun f y return using $369 = 1 + y *)
(* (* fun f y return using $370 = 1 + y *) *)
(* val a = f 1 *)

(* val f = fn x => x + 1 *)
(* val a = 1 + f 2 *)

datatype list 'a : {Nat} =
         Nil of list 'a {0}
       | Cons {n : Nat} of 'a * list 'a {n} --> list 'a {n + 1}

(* val ls = [] : list int {_} *)
(* val ls = [1, 2, 3] *)
val ls = [1, 2, 3, 4, 5]

(* fun length_int [a] {n : Nat} (l : list a {n}) return using $(2111*n + 976), 30*n+4 = *)
(*     case l return using $(2111*n + 777), 30*n+2 of *)
(*         [] => 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *)
(*       | _ :: xs => 1 + length_int xs *)

(* fun length_int [a] {n : Nat} (l : list a {n}) return using $(2111*n + 976), 30*n+4 = *)
(*     case l of *)
(*         [] => 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *)
(*       | _ :: xs => (1 + length_int xs) using $(2111*n+494), 30*n *)

fun length_int [a] {n : Nat} (l : list a {n}) =
    case l return using $(1362*n+777), 17*n+2 of
        [] => (0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0) using _
      | _ :: xs => (1 + length_int xs) using _

val a = length_int ls
           
(* fun waste_time () = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *)
(* (* fun waste_time a = *) *)
(* (*   let *) *)
(* (*     val _ = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *) *)
(* (*   in *) *)
(* (*     a *) *)
(* (*   end *) *)
                                                                                              
(* fun map ['a 'b] {m1 : Time} {m2 n : Nat} (f : 'a -- m1, m2 --> 'b) (ls : list (* 'a *)_ {n}) = *)
(*   case ls return list (* 'b *)_ {n} using (4007.0+m1)*$n+1460.0, (59+m2)*n+12 of *)
(*   (* case ls return using (4007.0+m1)*$n+1874.0, (59+m2)*n+18 of *) *)
(*       Nil => (let val _ = waste_time () in Nil end) (* using $1232, 10 *) *)
(*       (* Nil => waste_time Nil (* using $1232, 10 *) *) *)
(*     | Cons (x, xs) => Cons (f x, map f xs) *)
                                  
(* fun inc x = x + 1 *)
(* val a = map inc ls *)
                                 
(* val a = "abc" *)
          
(* val () = __&printc #"a" *)

(* val a = 1 *)
(* val a = () *)
(* val a = "" *)
          
(* val x = 1 + 2 *)
(* val y = x + 1 *)

(* fun f x = x + 1 *)
(* val a = f 253 *)
(* val a = f 0xdd *)
          
(* fun f x y = x + y *)
(* val a = f 1 2 *)
          
(* val foo = fn arg => arg + 1 *)
(* val a = foo 0xe1 *)

(* val p = (0xe1, 0xe2) *)
(* val a = __&fst p *)
(* val a = __&snd p *)
          
(* fun twice f x = f (f x) *)
(* fun f x = x + 1 *)
(* val a = twice f 0xdd *)
                  
(* datatype sum 'a 'b = *)
(*          inl of 'a --> sum 'a 'b *)
(*          | inr of 'b --> sum 'a 'b *)
                    
(* datatype empty = *)

(* val f = fn (a : empty) => case a return unit of *)
         
(* val f = fn (a : sum unit empty) => *)
(*            case a of *)
(*                inl () => () *)

(* val a = if 1 > 2 then 1 else 2 *)

(* val a = ifdec #1 #>= #2 then 1 else 2 *)

(* val a = #3 #+ #1 *)
(* val a = #3 #- #1 *)
(* val a = #3 #* #2 *)
(* val a = #5 #/ #2 *)
                               
(* fun fact_tail {n : Nat} (n : nat {n}, acc) = *)
(*   ifdec n #< #1 then acc *)
(*   else fact_tail (n #- #1, __&nat2int n *acc) using 4.0 * $n *)
                 
(* val a = fact_tail (#4, 1) *)
                  
(* fun fact {n : Nat} (n : nat {n}) = *)
(*   ifdec n #< #1 then 1 *)
(*   else *)
(*     __&nat2int n * fact (n #- #1) using 4.0 * $n *)
                 
(* val a = fact #4 *)
                 
(* (* val () = __&halt a *) *)
              
end
