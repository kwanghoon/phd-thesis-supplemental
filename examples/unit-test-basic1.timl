structure UnitTestBasic1 = struct

(* val f = fn y => 1 + y *)
(* val a = (f 64) using _ *)
(* val () = __&halt 0x1111 *)
(* val b = (f 64) using _ *)
                    
val x = 1
val f = fn y => 1 + y
fun f y = 1 + y
val f = fn y => x + y
fun f y = x + y
val a = (f 64) using _
val g = fn y => 1 + y
val b = f 64
val b = a + 2
val b = (a, 2)

val a = if __&false then 1 else 0

val x = 1
val f = fn {n : Nat} y => y + 1
val f = fn {n : Nat} => (fn y => y + 1) using _
val f = fn {n : Nat} y => x + y
fun f {n : Nat} y = y + 1
fun f {n : Nat} y = x + y
val a = @f {1}
val b = a 1
val a = @f {1} 1

val x = 1
val f = fn y => y
fun f y = y
val f = fn y => (x, y)
fun f y = (x, y)
val a = %f 1
val g = %f

val f = fn y => 1 + y
val g = fn y => f y
val a = g 64
          
datatype t2 'a = C {0 = 0} {1 = 1} of 'a --> t2 'a

val x =
    (let
      val (a, b) = (1, 2)
    in
      a
    end) using _
    
val x =
    (let
      val (_, C (_, x)) = ((), C ((), 2))
    in
      x
    end) using _
    
val f = (fn (_, ()) => ()) using _
fun f (_, ()) = ()
val a = (%f ((), ())) using _
val g = fn y => 1 + y
val a = (%f (g 1, ())) using _

datatype t2 'a = C {0 = 0} {1 = 1} of 'a --> t2 'a

val f = fn ((), C ((), x)) => x : int
val a = (f ((), C ((), 2))) using _
                            
val f = fn (_, C (_, x)) => x
val a = (%f ((), C ((), 2))) using _
                                                
val f = fn x => if x then 1 else 0
fun f x = if x then 1 else 0
val a = f __&false

datatype t = Fst | Snd
datatype t2 = C1 | C2 | C3 {n : Nat} {n = 0} of t --> t2

val a =
    (let
      val x = @C3 {0} {_} Snd
    in
      (case x of
           C1 => 1
         | C2 => 2
         | C3 Fst => 31
         | C3 Snd => 32) using _
    end) using _

val a = (case @C3 {0} {} Snd of
            C1 => 1
          | C2 => 2
          | C3 Fst => 31
          | C3 Snd => 32) using _

datatype t = C1

val a = (case C1 of
            C1 => 1) using _

val a =
    let
      val x = C1 using _
    in
    (case x of
         C1 => 1) using _
    end
                    
datatype t = C1 | C2

val a =
    let
      val x = C2 using _
    in
      (case x of
           C1 => 1
         | C2 => 2) using _
    end

val a = (case C2 of
            C1 => 1
          | C2 => 2) using _

val a =
    let
      val x = (C2, C2)
    in
      (case x of
           (_, C1) => 1
         | (C1, C2) => 12
         | (C2, C2) => 22) using _
    end

val a = (case (C2, C2) of
            (_, C1) => 1
          | (C1, C2) => 12
          | (C2, C2) => 22) using _

datatype t = C1 | C2 | C3

val a = (case C3 of
            C1 => 1
          | C2 => 2
          | C3 => 3) using _

datatype t = C1 | C2 | C3 | C4

val a = (case C4 of
            C1 => 1
          | C2 => 2
          | C3 => 3
          | C4 => 4) using _

datatype list 'a : {Nat} =
         Nil of list 'a {0}
       | Nil2 of list 'a {0}
       | Cons {n : Nat} of 'a * list 'a {n} --> list 'a {n + 1}

val a = (case Cons (1, Nil) of
            Nil => 1
          | Nil2 => 12
          | Cons _ => 2) using _

fun f y return using $369 = 1 + y
(* fun f y return using $370 = 1 + y *)
val a = f 1

val f = fn x => x + 1
val a = 1 + f 2

datatype list 'a : {Nat} =
         Nil of list 'a {0}
       | Cons {n : Nat} of 'a * list 'a {n} --> list 'a {n + 1}

(* val ls = [] : list int {_} *)
(* val ls = [1, 2, 3] *)
val ls = [1, 2, 3, 4, 5]

(* fun length_int [a] {n : Nat} (l : list a {n}) return using $(2111*n + 976), 30*n+4 = *)
(*     case l return using $(2111*n + 777), 30*n+2 of *)
(*         [] => 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *)
(*       | _ :: xs => 1 + length_int xs *)

(* fun length_int [a] {n : Nat} (l : list a {n}) return using $(2111*n + 976), 30*n+4 = *)
(*     case l of *)
(*         [] => 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 *)
(*       | _ :: xs => (1 + length_int xs) using $(2111*n+494), 30*n *)

fun length_int [a] {n : Nat} (l : list a {n}) =
    case l return using $(2111*n+777), 30*n+2 of
        [] => (0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0) using _
      | _ :: xs => (1 + (%length_int xs using _, _)) using _

val a = %length_int ls
           
fun waste_time () = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
                                                                                              
(* fun map ['a 'b] {m1 : Time} {m2 n : Nat} (f : 'a -- m1, m2 --> 'b) (ls : list _ {n}) = *)
(*   case ls return list _ {n} using (6524.0+m1)*$n+1767.0, (104+m2)*n+17 of *)
(*       Nil => let val _ = waste_time () in Nil end *)
(*     | Cons (x, xs) => Cons (f x, map f xs) *)

fun map ['a 'b] {m1 : Time} {m2 n : Nat} (f : 'a -- m1, m2 --> 'b) (ls : list _ {n}) =
  case ls return list _ {n} using (6524.0+m1)*$n+1767.0, (104+m2)*n+17 of
      Nil => waste_time (); Nil
    | Cons (x, xs) => Cons (f x, %map f xs)

fun inc x = x + 1
val a = %map inc ls
                                 
val a = "abc" using _, _
          
val () = __&printc #"a"

val a = 1
val a = ()
val a = ""
          
val x = 1 + 2
val y = x + 1

fun f x = x + 1
val a = f 253
val a = f 0xdd
          
fun f x y = x + y
val a = f 1 2
          
val foo = fn arg => arg + 1
val a = foo 0xe1

val p = (0xe1, 0xe2)
val a = __&fst p
val a = __&snd p
          
fun twice ['a] {m1 : Time} {m2 : Nat} (f : 'a -- m1,m2 --> _) x = %f (%f x)
fun f x = x + 1
val a = %twice f 0xdd
                  
(* datatype sum 'a 'b = *)
(*          inl of 'a --> sum 'a 'b *)
(*          | inr of 'b --> sum 'a 'b *)
                    
(* datatype empty = *)

(* val f = fn (a : empty) => case a return unit of *)
         
(* val f = fn (a : sum unit empty) => *)
(*            case a of *)
(*                inl () => () *)

(* fun assert p = if p then () else __&halt 0x11111111 *)
(* val () = assert (1 < 2) *)
(* val () = assert (not (2 < 1)) *)
(* val () = assert (2 > 1) *)
(* val () = assert (not (1 > 2)) *)
(* val () = assert (1 <= 2) *)
(* val () = assert (not (2 <= 1)) *)
(* val () = assert (2 >= 1) *)
(* val () = assert (not (1 >= 2)) *)
           
val a = (if 1 > 2 then 1 else 2) using _, _
val a = (ifdec #1 #>= #2 then 1 else 2) using _, _
                                     
fun f b = ifdec b then 1 else 2
val a = f (#1 #>= #2)

val a = #3 #+ #1
val a = #3 #- #1
val a = #3 #* #2
val a = #5 #/ #2
                               
fun waste_time () = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0

fun fact_tail {n : Nat} (n : nat {n}, acc) =
  ifdec n #< #1 then waste_time (); acc
  else %fact_tail (n #- #1, __&nat2int n *acc) using $(1780*n+1651), 25*n+16
                 
val a = (%fact_tail (#4, 1)) using _, _
                  
fun fact {n : Nat} (n : nat {n}) =
  ifdec n #< #1 then waste_time(); 1
  else
    __&nat2int n * %fact (n #- #1) using $(2170*n+1454), 31*n+13
                 
val a = (%fact #4) using _, _
                 
(* val () = __&halt a *)
              
end
